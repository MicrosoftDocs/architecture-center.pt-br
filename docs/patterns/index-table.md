---
title: Padrão de Tabela de Índice
titleSuffix: Cloud Design Patterns
description: Crie índices nos campos em armazenamentos de dados que são frequentemente referenciados por consultas.
keywords: padrão de design
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: e3373a50ba6298f7985182b7be244db5f6eaa703
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/20/2019
ms.locfileid: "58249291"
---
# <a name="index-table-pattern"></a><span data-ttu-id="f5fdc-104">Padrão de Tabela de Índice</span><span class="sxs-lookup"><span data-stu-id="f5fdc-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="f5fdc-105">Crie índices nos campos em armazenamentos de dados que são frequentemente referenciados por consultas.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="f5fdc-106">Esse padrão pode melhorar o desempenho de consulta, permitindo que os aplicativos localizem mais rapidamente os dados a serem recuperados de um armazenamento de dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="f5fdc-107">Contexto e problema</span><span class="sxs-lookup"><span data-stu-id="f5fdc-107">Context and problem</span></span>

<span data-ttu-id="f5fdc-108">Muitos armazenamento de dados organizam os dados para uma coleção de entidades utilizando a chave primária.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="f5fdc-109">Um aplicativo pode utilizar essa chave para localizar e recuperar dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="f5fdc-110">A figura mostra um exemplo de um armazenamento de dados que contém informações do cliente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="f5fdc-111">A chave primária é a ID do Cliente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="f5fdc-112">A figura mostra a informação do cliente organizada pela chave primária (ID do cliente).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![Figura 1 - Informações do cliente organizadas pela chave primária (ID do cliente)](./_images/index-table-figure-1.png)

<span data-ttu-id="f5fdc-114">Embora a chave primária seja valiosa para consultas que busquem dados baseados no valor dessa chave, um aplicativo talvez não seja capaz de utilizar a chave primária, caso precise recuperar dados baseados em algum outro campo.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="f5fdc-115">No exemplo de clientes, um aplicativo não pode utilizar a chave primária da ID do cliente para recuperar clientes se consultar os dados unicamente ao referenciar o valor de algum outro atributo, como a cidade em que o cliente está localizado.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="f5fdc-116">Para realizar uma consulta como essa, o aplicativo pode ter que buscar e examinar todos os registros de clientes, o que pode ser um processo lento.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="f5fdc-117">Muitos sistema de gerenciamento de banco de dados relacional fornecem suporte a índices secundários.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="f5fdc-118">Um índice secundário é uma estrutura de dados separada, organizada por um ou mais campos de chave não primários (secundários) e indica onde os dados de cada valor indexado são armazenados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="f5fdc-119">Os itens em um índice secundário normalmente são classificados pelo valor das chaves secundárias para permitir uma pesquisa rápida de dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="f5fdc-120">Esses índices geralmente são mantidos automaticamente pelo sistema gerenciador de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="f5fdc-121">É possível criar quantos índices secundários forem necessários para fornecer suporte às diferentes consultas que seu aplicativo executa.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="f5fdc-122">Por exemplo, em uma tabela de Clientes em um banco de dados relacional em que a ID do cliente é a chave primária, é útil adicionar um índice secundário sobre o campo da cidade, caso o aplicativo procure frequentemente os clientes pela cidade onde residem.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="f5fdc-123">No entanto, embora os índices secundários sejam comuns em sistemas relacionais, a maioria dos armazenamentos de dados NoSQL utilizados por aplicativos de nuvem não fornecem uma característica equivalente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="f5fdc-124">Solução</span><span class="sxs-lookup"><span data-stu-id="f5fdc-124">Solution</span></span>

<span data-ttu-id="f5fdc-125">Se o armazenamento de dados não fornecer suporte a índices secundários, você poderá emulá-los manualmente criando suas próprias tabelas de índice.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="f5fdc-126">Uma tabela de índice organiza os dados por uma chave especificada.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="f5fdc-127">Três estratégias são comumente utilizadas para estruturar uma tabela de índice, dependendo do número de índices secundários necessários e da natureza das consultas que um aplicativo executa.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="f5fdc-128">A primeira estratégia é duplicar os dados em cada tabela de índice, mas organizá-los por diferentes chaves (desnormalização completa).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="f5fdc-129">A próxima figura mostra tabelas de índice que organizam as mesmas informações do cliente por Cidade e Sobrenome.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![Figura 2 - Dados duplicados em cada tabela de índice](./_images/index-table-figure-2.png)

<span data-ttu-id="f5fdc-131">Esta estratégia é apropriada se os dados forem relativamente estáticos em relação ao número de vezes que ele é consultado utilizando cada chave.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="f5fdc-132">Se os dados forem mais dinâmicos, a sobrecarga de processamento da manutenção de cada tabela de índice será muito grande para que essa abordagem seja útil.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="f5fdc-133">Além disso, se o volume de dados for muito grande, a quantidade de espaço necessário para armazenar os dados duplicados for significativa.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="f5fdc-134">A segunda estratégia é criar tabelas de índice normalizadas organizadas por diferentes chaves e referenciar os dados originais utilizando a chave primária em vez de duplicá-la, conforme mostrado na figura a seguir.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="f5fdc-135">Os dados originais são chamados de tabela de fatos.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-135">The original data is called a fact table.</span></span>

![Figura 3 - Os dados são referenciados por cada tabela de índice](./_images/index-table-figure-3.png)

<span data-ttu-id="f5fdc-137">Essa técnica economiza espaço e reduz a sobrecarga da manutenção de dados duplicados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="f5fdc-138">A desvantagem é que um aplicativo deve executar duas operações de pesquisa para localizar dados utilizando uma chave secundária.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="f5fdc-139">Ele deve localizar a chave primária para os dados na tabela de índice e, em seguida, usar a chave primária para pesquisar os dados na tabela de fatos.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="f5fdc-140">A terceira estratégia é criar tabelas de índice parcialmente normalizadas organizadas por diferentes chaves que dupliquem campos frequentemente recuperados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="f5fdc-141">Consulte a tabela de fatos para acessar campos com acesso menor.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="f5fdc-142">A próxima figura mostra como os dados com acesso comum são duplicados em cada tabela de índice.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![Figura 4 - Dados normalmente acessados são duplicados em cada tabela de índice](./_images/index-table-figure-4.png)

<span data-ttu-id="f5fdc-144">Com essa estratégia, você pode estabelecer um equilíbrio entre as duas primeiras abordagens.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="f5fdc-145">Os dados para consultas comuns podem ser recuperados rapidamente, utilizando uma pesquisa única, enquanto o espaço e a sobrecarga de manutenção não são tão significativos quanto a duplicação de todo o conjunto de dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="f5fdc-146">Se um aplicativo frequentemente consulta dados, especificando uma combinação de valores (por exemplo, "Localizar todos os clientes que vivem em Redmond e que tenham um sobrenome de Smith"), você poderá implementar as chaves dos itens na tabela de índice como uma concatenação do atributo Cidade e do atributo Sobrenome.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="f5fdc-147">A figura a seguir mostra uma tabela de índice baseada em chaves compostas.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="f5fdc-148">As chaves são classificadas por Cidade e, em seguida, por Sobrenome para registros que tenham o mesmo valor para Cidade.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![Figura 5 - Uma tabela de índice baseada em chaves compostas](./_images/index-table-figure-5.png)

<span data-ttu-id="f5fdc-150">As tabelas de índice podem acelerar as operações de consulta em relação aos dados fragmentados e são especialmente úteis quando a chave de fragmento for com hash.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="f5fdc-151">A próxima figura mostra um exemplo em que a chave de fragmento é um hash da ID do Cliente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="f5fdc-152">A tabela de índice pode organizar dados pelo valor sem hash (Cidade e Sobrenome) e fornecer a chave de fragmento com hash como o dado de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="f5fdc-153">Isso pode salvar o aplicativo de cálculos repetidos de chaves de hash (uma operação cara) se precisar recuperar dados que caiam em um intervalo ou, precise buscar dados em ordem de chave sem hash.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="f5fdc-154">Por exemplo, uma consulta como "Localizar todos os clientes que vivem em Redmond" pode ser rapidamente resolvida, localizando os itens correspondentes na tabela de índice, onde são todos armazenados em um bloco contíguo.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="f5fdc-155">Em seguida, siga as referências para os dados do cliente, utilizando as chaves de fragmento armazenadas na tabela de índice.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![Figura 6 - Uma tabela de índice que fornece pesquisa rápida para dados fragmentados](./_images/index-table-figure-6.png)

## <a name="issues-and-considerations"></a><span data-ttu-id="f5fdc-157">Problemas e considerações</span><span class="sxs-lookup"><span data-stu-id="f5fdc-157">Issues and considerations</span></span>

<span data-ttu-id="f5fdc-158">Considere os seguintes pontos ao decidir como implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="f5fdc-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="f5fdc-159">A sobrecarga da manutenção de índices secundários pode ser significativa.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="f5fdc-160">Você deve analisar e entender as consultas que seu aplicativo utiliza.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="f5fdc-161">Apenas crie tabelas de índice quando elas provavelmente serão utilizadas regularmente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="f5fdc-162">Não crie tabelas de índice especulativa para fornecer suporte a consultas que um aplicativo não executa ou que executa apenas ocasionalmente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="f5fdc-163">Duplicar dados em uma tabela de índice pode adicionar sobrecarga significativa nos custos de armazenamento e no esforço necessário para manter várias cópias de dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="f5fdc-164">A implementação de uma tabela de índice como uma estrutura normalizada que faz referência aos dados originais requer um aplicativo para executar duas operações de pesquisa para localizar dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="f5fdc-165">A primeira operação pesquisa a tabela de índice para recuperar a chave primária e a segunda utiliza a chave primária para buscar os dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="f5fdc-166">Se um sistema incorporar uma série de tabelas de índice em conjuntos de dados muito grandes, poderá ser difícil manter a consistência entre as tabelas de índice e os dados originais.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="f5fdc-167">Pode ser possível projetar o aplicativo em torno do modelo de coerência eventual.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="f5fdc-168">Por exemplo, para inserir, atualizar ou excluir dados, um aplicativo pode enviar uma mensagem para uma fila e permitir que uma tarefa separada execute a operação e mantenha as tabelas de índice que fazem referência a esses dados de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="f5fdc-169">Para obter mais informações sobre como implementar a coerência eventual, consulte o [Primer de consistência de dados](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="f5fdc-170">As tabelas de armazenamento do Microsoft Azure fornecem suporte a atualizações transacionais para alterações feitas nos dados mantidos na mesma partição (referidas como transações de grupos da entidade).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="f5fdc-171">Se for possível armazenar os dados para uma tabela de fatos e uma ou mais tabelas de índice na mesma partição, você poderá utilizar esse recurso para garantir a consistência.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="f5fdc-172">As tabelas de índice podem ser particionadas ou fragmentadas.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="f5fdc-173">Quando usar esse padrão</span><span class="sxs-lookup"><span data-stu-id="f5fdc-173">When to use this pattern</span></span>

<span data-ttu-id="f5fdc-174">Utilize esse padrão para melhorar o desempenho de consulta quando um aplicativo frequentemente precisar recuperar dados utilizando uma tecla diferente da chave primária (ou fragmento).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="f5fdc-175">Esse padrão pode não ser útil quando:</span><span class="sxs-lookup"><span data-stu-id="f5fdc-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="f5fdc-176">Os dados forem voláteis.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-176">Data is volatile.</span></span> <span data-ttu-id="f5fdc-177">Uma tabela de índice pode tornar-se desatualizada muito rapidamente, tornando-a ineficaz ou fazendo com que a sobrecarga de manutenção da tabela de índice seja maior do que qualquer economia feita durante a utilização.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="f5fdc-178">Um campo selecionado como a chave secundária para uma tabela de índice não é discriminatório e somente poderá ter um conjunto de valores pequeno (por exemplo, gênero).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="f5fdc-179">O equilíbrio dos valores de dados para um campo selecionado como a chave secundária para uma tabela de índice é altamente distorcido.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="f5fdc-180">Por exemplo, se 90% dos registros contiverem o mesmo valor em um campo, a criação e manutenção de uma tabela de índice para pesquisar dados com base nesse campo pode criar mais sobrecarga do que examinar sequencialmente através dos dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="f5fdc-181">No entanto, se as consultas com frequência atingirem valores que se situam nos restantes 10%, esse índice poderá ser útil.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="f5fdc-182">Você deve entender as consultas que seu aplicativo está executando e a frequência com que são executados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="f5fdc-183">Exemplo</span><span class="sxs-lookup"><span data-stu-id="f5fdc-183">Example</span></span>

<span data-ttu-id="f5fdc-184">As tabelas de armazenamento do Azure fornecem um armazenamento de dados valor/chave altamente escalonável para aplicativos em execução na nuvem.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="f5fdc-185">Os aplicativos armazenam e recuperam valores de dados especificando uma chave.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="f5fdc-186">Os valores de dados podem conter vários campos, mas a estrutura de um item de dados é opaca para armazenamento de tabela, que simplesmente administra um item de dados como uma matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="f5fdc-187">As tabelas de armazenamento do Azure também fornecem suporte para fragmentação.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="f5fdc-188">A chave de fragmentação inclui dois elementos, uma chave de partição e uma chave de linha.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="f5fdc-189">Os itens que possuem a mesma chave de partição são armazenados na mesma partição (fragmento) e os itens são armazenados na ordem das linhas do item dentro de um fragmento.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="f5fdc-190">O armazenamento de tabelas é otimizado para realizar consultas que buscam dados que caem em um intervalo contíguo de valores de linha de linha dentro de uma partição.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="f5fdc-191">Se você estiver construindo aplicativos de nuvem que armazenam informações em tabelas do Azure, será necessário estruturar seus dados com esse recurso em mente.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="f5fdc-192">Por exemplo, considere um aplicativo que armazena informações sobre filmes.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="f5fdc-193">O aplicativo frequentemente consulta filmes por gênero (ação, documentário, histórico, comédia, drama, etc.).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="f5fdc-194">Você poderia criar uma tabela do Azure com partições para cada gênero, utilizando o gênero como a chave de partição e especificando o nome do filme como a chave de linha, conforme mostrado na próxima figura.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![Figura 7 - Dados do filme armazenados em uma tabela do Azure](./_images/index-table-figure-7.png)

<span data-ttu-id="f5fdc-196">Essa abordagem é menos efetiva se o aplicativo também precisar consultar filmes por ator principal.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="f5fdc-197">Nesse caso, é possível criar uma tabela do Azure separada que age como uma tabela de índice.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="f5fdc-198">A chave de partição é o ator e a chave de linha é o nome do filme.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="f5fdc-199">Os dados para cada ator serão armazenados em partições separadas.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="f5fdc-200">Se um filme estrelar mais de um ator, o mesmo filme ocorrerá em várias partições.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="f5fdc-201">É possível duplicar os dados do filme nos valores mantidos por cada partição, adotando a primeira abordagem descrita na seção Solução acima.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="f5fdc-202">No entanto, é provável que cada filme seja replicado várias vezes (uma vez por cada ator), por isso, pode ser mais eficiente desnormalizar parcialmente os dados para fornecer suporte às consultas mais comuns (como os nomes dos outros atores) e habilitar um aplicativo para recuperar os detalhes restantes, incluindo a chave de partição necessária para localizar a informação completa nas partições de gênero.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="f5fdc-203">Essa abordagem é descrita pela terceira opção na seção Solução.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="f5fdc-204">A próxima figura mostra essa abordagem.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-204">The next figure shows this approach.</span></span>

![Figura 8 - Partições de ator que atuam como tabelas de índice para dados do filme](./_images/index-table-figure-8.png)

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="f5fdc-206">Diretrizes e padrões relacionados</span><span class="sxs-lookup"><span data-stu-id="f5fdc-206">Related patterns and guidance</span></span>

<span data-ttu-id="f5fdc-207">Os padrões e diretrizes a seguir também podem ser relevantes ao implementar esse padrão:</span><span class="sxs-lookup"><span data-stu-id="f5fdc-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="f5fdc-208">[Primer de Consistência de Dados](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="f5fdc-209">Uma tabela de índice deve ser mantida à medida que os dados que indexa as alterações.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="f5fdc-210">Na nuvem, pode não ser possível ou apropriado executar operações que atualizem um índice como parte da mesma transação que altera os dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="f5fdc-211">Nesse caso, uma abordagem eventualmente coerente é mais apropriada.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="f5fdc-212">Fornece informações sobre as questões relacionadas com a coerência eventual.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="f5fdc-213">[Padrão de Fragmentação](./sharding.md).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-213">[Sharding pattern](./sharding.md).</span></span> <span data-ttu-id="f5fdc-214">O padrão da tabela de índice é frequentemente utilizado em conjunto com dados compartilhados usando fragmentos.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="f5fdc-215">O padrão de Fragmentação fornece mais informações sobre como dividir um armazenamento de dados em um conjunto de fragmentos.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="f5fdc-216">[Padrão de Exibição Materializada](./materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="f5fdc-216">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="f5fdc-217">Em vez de indexar dados para fornecer suporte às consultas que resumem dados, talvez seja mais apropriado criar uma exibição materializada dos dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="f5fdc-218">Descreve como fornecer suporte às consultas de resumo eficientes, gerando exibições pré-populadas sobre dados.</span><span class="sxs-lookup"><span data-stu-id="f5fdc-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
