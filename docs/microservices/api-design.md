---
title: Design de API
description: Criando APIs para microsserviços
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 01f774773b2d2a653e52c9ee961f12c5b9fc833a
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54485971"
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="dcdac-103">Como criar microsserviços: Design de API</span><span class="sxs-lookup"><span data-stu-id="dcdac-103">Designing microservices: API design</span></span>

<span data-ttu-id="dcdac-104">Um bom design de API é importante em uma arquitetura de microsserviços porque toda a troca de dados entre os serviços ocorre por meio de mensagens ou de chamadas à API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="dcdac-105">As APIs devem ser eficientes para evitar a criação de [E/S com ruídos](../antipatterns/chatty-io/index.md).</span><span class="sxs-lookup"><span data-stu-id="dcdac-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="dcdac-106">Uma vez que os serviços são projetados por equipes que trabalham de forma independente, as APIs devem ter esquemas semânticos e de controle de versão bem definidos para que as atualizações não interrompam outros serviços.</span><span class="sxs-lookup"><span data-stu-id="dcdac-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![Design de API para microsserviços](./images/api-design.png)

<span data-ttu-id="dcdac-108">É importante distinguir entre os dois tipos de API:</span><span class="sxs-lookup"><span data-stu-id="dcdac-108">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="dcdac-109">As APIs públicas que os aplicativos do cliente chamam.</span><span class="sxs-lookup"><span data-stu-id="dcdac-109">Public APIs that client applications call.</span></span>
- <span data-ttu-id="dcdac-110">As APIs de back-end que são usadas para comunicação entre serviços.</span><span class="sxs-lookup"><span data-stu-id="dcdac-110">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="dcdac-111">Esses dois casos de uso têm requisitos um pouco diferentes.</span><span class="sxs-lookup"><span data-stu-id="dcdac-111">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="dcdac-112">Uma API pública deve ser compatível com aplicativos cliente, normalmente os aplicativos de navegador ou os aplicativos móveis nativos.</span><span class="sxs-lookup"><span data-stu-id="dcdac-112">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="dcdac-113">Na maioria das vezes, isso significa que a API pública usará o REST sobre o HTTP.</span><span class="sxs-lookup"><span data-stu-id="dcdac-113">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="dcdac-114">No entanto, para as APIs de back-end, você precisa levar em conta o desempenho da rede.</span><span class="sxs-lookup"><span data-stu-id="dcdac-114">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="dcdac-115">Dependendo da granularidade dos seus serviços, a comunicação entre serviços pode resultar em uma grande quantidade de tráfego de rede.</span><span class="sxs-lookup"><span data-stu-id="dcdac-115">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="dcdac-116">Os serviços podem rapidamente se tornar um limite de E/S.</span><span class="sxs-lookup"><span data-stu-id="dcdac-116">Services can quickly become I/O bound.</span></span> <span data-ttu-id="dcdac-117">Por esse motivo, considerações como a velocidade de serialização e o tamanho de payload se tornam mais importantes.</span><span class="sxs-lookup"><span data-stu-id="dcdac-117">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="dcdac-118">Algumas alternativas populares para usar o REST sobre o HTTP incluem gRPC, Apache Avro e Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="dcdac-118">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="dcdac-119">Esses protocolos são compatíveis com a serialização binária e geralmente são mais eficientes do que o HTTP.</span><span class="sxs-lookup"><span data-stu-id="dcdac-119">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="dcdac-120">Considerações</span><span class="sxs-lookup"><span data-stu-id="dcdac-120">Considerations</span></span>

<span data-ttu-id="dcdac-121">Aqui estão algumas questões a serem consideradas ao escolher como implementar uma API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-121">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="dcdac-122">**REST versus RPC**.</span><span class="sxs-lookup"><span data-stu-id="dcdac-122">**REST vs RPC**.</span></span> <span data-ttu-id="dcdac-123">Considere as compensações entre o uso de uma interface no estilo REST em vez de uma interface no estilo RPC.</span><span class="sxs-lookup"><span data-stu-id="dcdac-123">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="dcdac-124">O REST modela recursos, o que pode ser uma maneira natural de expressar seu modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="dcdac-124">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="dcdac-125">Ele define uma interface uniforme com base nos verbos HTTP, o que incentiva a evolucionabilidade.</span><span class="sxs-lookup"><span data-stu-id="dcdac-125">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="dcdac-126">Ele tem uma semântica bem definida em termos de idempotência, efeitos colaterais e códigos de resposta.</span><span class="sxs-lookup"><span data-stu-id="dcdac-126">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="dcdac-127">E impõe uma comunicação sem monitoração de estado, o que melhora a escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="dcdac-127">And it enforces stateless communication, which improves scalability.</span></span>

- <span data-ttu-id="dcdac-128">O RPC está mais voltado para as operações ou para os comandos.</span><span class="sxs-lookup"><span data-stu-id="dcdac-128">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="dcdac-129">Uma vez que as interfaces de RPC se parecem com chamadas de método locais, talvez você acabe criando APIs extremamente ruidosas.</span><span class="sxs-lookup"><span data-stu-id="dcdac-129">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="dcdac-130">No entanto, isso não significa que o RPC deve ser ruidoso.</span><span class="sxs-lookup"><span data-stu-id="dcdac-130">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="dcdac-131">Isso apenas indica que você precisa ter cuidado ao criar a interface.</span><span class="sxs-lookup"><span data-stu-id="dcdac-131">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="dcdac-132">Para obter uma interface RESTful, a opção mais comum é REST sobre HTTP usando JSON.</span><span class="sxs-lookup"><span data-stu-id="dcdac-132">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="dcdac-133">Para obter uma interface no estilo RPC, há várias estruturas populares, incluindo gRPC, Apache Avro e Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="dcdac-133">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.</span></span>

<span data-ttu-id="dcdac-134">**Eficiência**.</span><span class="sxs-lookup"><span data-stu-id="dcdac-134">**Efficiency**.</span></span> <span data-ttu-id="dcdac-135">Considere a eficiência em termos de velocidade, memória e tamanho de payload.</span><span class="sxs-lookup"><span data-stu-id="dcdac-135">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="dcdac-136">Normalmente, uma interface baseada em gRPC é mais rápida que REST sobre HTTP.</span><span class="sxs-lookup"><span data-stu-id="dcdac-136">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="dcdac-137">**IDL (linguagem IDL)**.</span><span class="sxs-lookup"><span data-stu-id="dcdac-137">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="dcdac-138">Uma IDL é usada para definir os métodos, os parâmetros e os valores retornados de uma API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-138">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="dcdac-139">Um IDL pode ser usado para gerar o código do cliente, o código de serialização e a documentação da API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-139">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="dcdac-140">Os IDLs também podem ser consumidos por ferramentas de teste da API, como o Postman.</span><span class="sxs-lookup"><span data-stu-id="dcdac-140">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="dcdac-141">Estruturas como gRPC, Avro e Thrift definem suas próprias especificações de IDL.</span><span class="sxs-lookup"><span data-stu-id="dcdac-141">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="dcdac-142">O REST sobre HTTP não tem um formato padrão de IDL, mas uma opção comum é o OpenAPI (anteriormente conhecido como Swagger).</span><span class="sxs-lookup"><span data-stu-id="dcdac-142">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="dcdac-143">Você também pode criar uma API de REST HTTP sem usar uma linguagem de definição formal, mas perderá os benefícios da geração de código e de teste.</span><span class="sxs-lookup"><span data-stu-id="dcdac-143">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="dcdac-144">**Serialização**.</span><span class="sxs-lookup"><span data-stu-id="dcdac-144">**Serialization**.</span></span> <span data-ttu-id="dcdac-145">Como os objetos são serializados eletronicamente?</span><span class="sxs-lookup"><span data-stu-id="dcdac-145">How are objects serialized over the wire?</span></span> <span data-ttu-id="dcdac-146">As opções incluem formatos baseados em texto (principalmente JSON) e formatos binários, como um buffer de protocolo.</span><span class="sxs-lookup"><span data-stu-id="dcdac-146">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="dcdac-147">Os formatos binários geralmente são mais rápidos do que os formatos baseados em texto.</span><span class="sxs-lookup"><span data-stu-id="dcdac-147">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="dcdac-148">No entanto, o JSON tem vantagens em termos de interoperabilidade porque a maioria das linguagens e das estruturas são compatíveis com a serialização JSON.</span><span class="sxs-lookup"><span data-stu-id="dcdac-148">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="dcdac-149">Alguns formatos de serialização exigem um esquema fixo e alguns exigem a compilação de um arquivo de definição de esquema.</span><span class="sxs-lookup"><span data-stu-id="dcdac-149">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="dcdac-150">Nesse caso, você precisará incorporar essa etapa no processo de build.</span><span class="sxs-lookup"><span data-stu-id="dcdac-150">In that case, you'll need to incorporate this step into your build process.</span></span>

<span data-ttu-id="dcdac-151">**Suporte de estrutura e linguagem**.</span><span class="sxs-lookup"><span data-stu-id="dcdac-151">**Framework and language support**.</span></span> <span data-ttu-id="dcdac-152">O HTTP é compatível com praticamente todas as estruturas e idiomas.</span><span class="sxs-lookup"><span data-stu-id="dcdac-152">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="dcdac-153">gRPC, Avro e Thrift têm bibliotecas para C++, C#, Java e Python.</span><span class="sxs-lookup"><span data-stu-id="dcdac-153">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="dcdac-154">Thrift e gRPC também são compatíveis com Go.</span><span class="sxs-lookup"><span data-stu-id="dcdac-154">Thrift and gRPC also support Go.</span></span>

<span data-ttu-id="dcdac-155">**Compatibilidade e interoperabilidade**.</span><span class="sxs-lookup"><span data-stu-id="dcdac-155">**Compatibility and interoperability**.</span></span> <span data-ttu-id="dcdac-156">Se escolher um protocolo como gRPC, talvez você precisará de uma camada de conversão de protocolo entre a API pública e o back-end.</span><span class="sxs-lookup"><span data-stu-id="dcdac-156">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="dcdac-157">Um [gateway](./gateway.md) pode executar essa função.</span><span class="sxs-lookup"><span data-stu-id="dcdac-157">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="dcdac-158">Se você estiver usando uma malha de serviço, considere quais protocolos são compatíveis com ela.</span><span class="sxs-lookup"><span data-stu-id="dcdac-158">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="dcdac-159">Por exemplo, linkerd tem suporte interno para HTTP, Thrift e gRPC.</span><span class="sxs-lookup"><span data-stu-id="dcdac-159">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span>

<span data-ttu-id="dcdac-160">Nossa recomendação de linha de base é escolher REST sobre HTTP, a menos que você precise dos benefícios de desempenho de um protocolo binário.</span><span class="sxs-lookup"><span data-stu-id="dcdac-160">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="dcdac-161">O REST sobre HTTP não requer nenhuma biblioteca especial.</span><span class="sxs-lookup"><span data-stu-id="dcdac-161">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="dcdac-162">Ele cria um acoplamento mínimo, uma vez que os autores da chamada não precisam de um stub de cliente para se comunicarem com o serviço.</span><span class="sxs-lookup"><span data-stu-id="dcdac-162">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="dcdac-163">Há ecossistemas avançados de ferramentas para dar suporte às definições de esquema, teste e monitoramento de pontos de extremidade de HTTP RESTful.</span><span class="sxs-lookup"><span data-stu-id="dcdac-163">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="dcdac-164">Por fim, o HTTP é compatível com clientes de navegador, portanto, você não precisa de uma camada de conversão de protocolo entre o cliente e o back-end.</span><span class="sxs-lookup"><span data-stu-id="dcdac-164">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span>

<span data-ttu-id="dcdac-165">No entanto, se escolher o REST sobre HTTP, você deverá fazer testes de carga e de desempenho no início do processo de desenvolvimento para validar se ele funciona bem o suficiente para o seu cenário.</span><span class="sxs-lookup"><span data-stu-id="dcdac-165">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="dcdac-166">Projeto de API RESTful</span><span class="sxs-lookup"><span data-stu-id="dcdac-166">RESTful API design</span></span>

<span data-ttu-id="dcdac-167">Há muitos recursos para a criação de APIs RESTful.</span><span class="sxs-lookup"><span data-stu-id="dcdac-167">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="dcdac-168">Aqui estão alguns que podem ser úteis:</span><span class="sxs-lookup"><span data-stu-id="dcdac-168">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="dcdac-169">Design de API</span><span class="sxs-lookup"><span data-stu-id="dcdac-169">API design</span></span>](../best-practices/api-design.md)

- [<span data-ttu-id="dcdac-170">Implementação da API</span><span class="sxs-lookup"><span data-stu-id="dcdac-170">API implementation</span></span>](../best-practices/api-implementation.md)

- [<span data-ttu-id="dcdac-171">Diretrizes da API REST da Microsoft</span><span class="sxs-lookup"><span data-stu-id="dcdac-171">Microsoft REST API Guidelines</span></span>](https://github.com/Microsoft/api-guidelines)

<span data-ttu-id="dcdac-172">Aqui estão algumas considerações específicas para ter em mente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-172">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="dcdac-173">Fique atento às APIs que vazam detalhes de implementação internos ou refletem um esquema de banco de dados interno.</span><span class="sxs-lookup"><span data-stu-id="dcdac-173">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="dcdac-174">A API deve modelar o domínio.</span><span class="sxs-lookup"><span data-stu-id="dcdac-174">The API should model the domain.</span></span> <span data-ttu-id="dcdac-175">É um contrato entre serviços e, de modo ideal, só deve ser alterado quando novas funcionalidades forem adicionadas, não apenas porque você refatorou algum código ou normalizou uma tabela de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="dcdac-175">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span>

- <span data-ttu-id="dcdac-176">Diferentes tipos de cliente, como o aplicativo móvel e o navegador da Web da área de trabalho, podem exigir tamanhos diferentes de payload ou padrões de interação.</span><span class="sxs-lookup"><span data-stu-id="dcdac-176">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="dcdac-177">Considere o uso de [back-ends para front-ends padrão](../patterns/backends-for-frontends.md) para criar back-ends separados para cada cliente, que expõem uma interface ideal para esse cliente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-177">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="dcdac-178">Para as operações com efeitos colaterais, considere torná-los idempotentes e implementá-los como métodos PUT.</span><span class="sxs-lookup"><span data-stu-id="dcdac-178">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="dcdac-179">Isso habilitará tentativas seguras e poderá melhorar a resiliência.</span><span class="sxs-lookup"><span data-stu-id="dcdac-179">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="dcdac-180">Os capítulos [Ingestão de dados e fluxo de trabalho](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) e [Comunicação entre serviços](./interservice-communication.md) abordam esse problema de forma mais detalhada.</span><span class="sxs-lookup"><span data-stu-id="dcdac-180">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="dcdac-181">Os métodos HTTP podem ter uma semântica assíncrona, em que o método retorna uma resposta imediatamente, mas o serviço realiza a operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="dcdac-181">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="dcdac-182">Nesse caso, o método deve retornar um código de resposta [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), que indica que a solicitação foi aceita para processamento, mas o processamento ainda não foi concluído.</span><span class="sxs-lookup"><span data-stu-id="dcdac-182">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="dcdac-183">Mapeamento de REST para padrões de DDD</span><span class="sxs-lookup"><span data-stu-id="dcdac-183">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="dcdac-184">Os padrões como entidade, agregação e objeto de valor são projetados para colocar determinadas restrições nos objetos em seu modelo de domínio.</span><span class="sxs-lookup"><span data-stu-id="dcdac-184">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="dcdac-185">Em muitas discussões de DDD, os padrões são modelados usando conceitos da linguagem orientada a objeto (OO), como construtores ou getters e setters de propriedade.</span><span class="sxs-lookup"><span data-stu-id="dcdac-185">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="dcdac-186">Por exemplo, os *objetos de valor* devem ser imutáveis.</span><span class="sxs-lookup"><span data-stu-id="dcdac-186">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="dcdac-187">Em uma linguagem de programação OO, você aplicaria isso ao atribuir os valores no construtor e tornando as propriedades somente leitura:</span><span class="sxs-lookup"><span data-stu-id="dcdac-187">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="dcdac-188">Esses tipos de práticas recomendadas de codificação são particularmente importantes ao criar um aplicativo monolítico tradicional.</span><span class="sxs-lookup"><span data-stu-id="dcdac-188">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="dcdac-189">Com uma base de código grande, muitos subsistemas podem usar o objeto `Location`, portanto, é importante que o objeto imponha o comportamento correto.</span><span class="sxs-lookup"><span data-stu-id="dcdac-189">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span>

<span data-ttu-id="dcdac-190">Outro exemplo é o padrão Repositório, que garante que outras partes do aplicativo não façam leituras ou gravações diretas no armazenamento de dados:</span><span class="sxs-lookup"><span data-stu-id="dcdac-190">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

![Diagrama de um Repositório do Drone](./images/repository.png)

<span data-ttu-id="dcdac-192">Em uma arquitetura de microsserviços, no entanto, os serviços não compartilham a mesma base de código, nem os repositórios de dados.</span><span class="sxs-lookup"><span data-stu-id="dcdac-192">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="dcdac-193">Em vez disso, eles se comunicam por meio de APIs.</span><span class="sxs-lookup"><span data-stu-id="dcdac-193">Instead, they communicate through APIs.</span></span> <span data-ttu-id="dcdac-194">Considere o caso em que o serviço Agendador solicita informações sobre um drone do serviço Drone.</span><span class="sxs-lookup"><span data-stu-id="dcdac-194">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="dcdac-195">O serviço Drone tem seu modelo interno de drone expresso através de código.</span><span class="sxs-lookup"><span data-stu-id="dcdac-195">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="dcdac-196">Mas o Agendador não o vê.</span><span class="sxs-lookup"><span data-stu-id="dcdac-196">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="dcdac-197">Em vez disso, ele recupera uma *representação* da entidade &mdash; do drone, talvez um objeto JSON em uma resposta de HTTP.</span><span class="sxs-lookup"><span data-stu-id="dcdac-197">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![Diagrama do serviço Drone](./images/ddd-rest.png)

<span data-ttu-id="dcdac-199">O serviço Agendador não pode modificar os modelos internos de serviço do Drone ou gravar no armazenamento de dados de serviço do Drone.</span><span class="sxs-lookup"><span data-stu-id="dcdac-199">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="dcdac-200">Isso indica que o código que implementa o serviço Drone tem uma área de superfície exposta menor em comparação com o código em um monolito tradicional.</span><span class="sxs-lookup"><span data-stu-id="dcdac-200">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="dcdac-201">Se o serviço Drone definir uma classe Local, o escopo dessa classe será limitado a &mdash;, nenhum outro serviço consumirá a classe diretamente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-201">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span>

<span data-ttu-id="dcdac-202">Por esses motivos, este guia não se concentra muito em práticas recomendadas de codificação, uma vez que elas se relacionam com os padrões de DDD táticos.</span><span class="sxs-lookup"><span data-stu-id="dcdac-202">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="dcdac-203">Mas acontece também que você pode modelar muitos dos padrões de DDD por meio das APIs REST.</span><span class="sxs-lookup"><span data-stu-id="dcdac-203">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span>

<span data-ttu-id="dcdac-204">Por exemplo: </span><span class="sxs-lookup"><span data-stu-id="dcdac-204">For example:</span></span>

- <span data-ttu-id="dcdac-205">As agregações naturalmente mapeiam para os *recursos* em REST.</span><span class="sxs-lookup"><span data-stu-id="dcdac-205">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="dcdac-206">Por exemplo, a agregação Entrega deve ser exposta como um recurso pela API Entrega.</span><span class="sxs-lookup"><span data-stu-id="dcdac-206">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="dcdac-207">As agregações são os limites de consistência.</span><span class="sxs-lookup"><span data-stu-id="dcdac-207">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="dcdac-208">As operações em agregações nunca devem deixar uma agregação em um estado inconsistente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-208">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="dcdac-209">Portanto, você deve evitar criar APIs que permitem que um cliente manipule o estado interno de uma agregação.</span><span class="sxs-lookup"><span data-stu-id="dcdac-209">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="dcdac-210">Em vez disso, favoreça as APIs de alta granularidade que expõem agregações como recursos.</span><span class="sxs-lookup"><span data-stu-id="dcdac-210">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="dcdac-211">As entidades têm identidades exclusivas.</span><span class="sxs-lookup"><span data-stu-id="dcdac-211">Entities have unique identities.</span></span> <span data-ttu-id="dcdac-212">No REST, os recursos têm identificadores exclusivos na forma de URLs.</span><span class="sxs-lookup"><span data-stu-id="dcdac-212">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="dcdac-213">Crie URLs de recursos que correspondam à identidade de domínio da entidade.</span><span class="sxs-lookup"><span data-stu-id="dcdac-213">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="dcdac-214">O mapeamento da URL para a identidade de domínio pode parecer vago para o cliente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-214">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="dcdac-215">As entidades filho de uma agregação podem ser alcançadas por meio da navegação da entidade raiz.</span><span class="sxs-lookup"><span data-stu-id="dcdac-215">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="dcdac-216">Se você seguir os princípios [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS), as entidades filho poderão ser acessadas por meio de links na representação da entidade pai.</span><span class="sxs-lookup"><span data-stu-id="dcdac-216">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span>

- <span data-ttu-id="dcdac-217">Uma vez que os objetos de valor são imutáveis, as atualizações são executadas, substituindo o objeto de valor inteiro.</span><span class="sxs-lookup"><span data-stu-id="dcdac-217">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="dcdac-218">No REST, implante as atualizações por meio das solicitações PUT ou PATCH.</span><span class="sxs-lookup"><span data-stu-id="dcdac-218">In REST, implement updates through PUT or PATCH requests.</span></span>

- <span data-ttu-id="dcdac-219">Um repositório permite aos clientes consultar, adicionar ou remover objetos em uma coleção, abstraindo os detalhes do armazenamento de dados subjacente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-219">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="dcdac-220">No REST, uma coleção pode ser um recurso distinto, com métodos para consultar a coleção ou adicionar novas entidades na coleção.</span><span class="sxs-lookup"><span data-stu-id="dcdac-220">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="dcdac-221">Quando você projeta suas APIs, pense em como elas expressam o modelo de domínio, não apenas nos dados dentro do modelo, mas também nas operações de negócios e nas restrições nos dados.</span><span class="sxs-lookup"><span data-stu-id="dcdac-221">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="dcdac-222">Conceito de DDD</span><span class="sxs-lookup"><span data-stu-id="dcdac-222">DDD concept</span></span> | <span data-ttu-id="dcdac-223">Equivalente a REST</span><span class="sxs-lookup"><span data-stu-id="dcdac-223">REST equivalent</span></span> | <span data-ttu-id="dcdac-224">Exemplo</span><span class="sxs-lookup"><span data-stu-id="dcdac-224">Example</span></span> |
|-------------|-----------------|---------|
| <span data-ttu-id="dcdac-225">Agregação</span><span class="sxs-lookup"><span data-stu-id="dcdac-225">Aggregate</span></span> | <span data-ttu-id="dcdac-226">Recurso</span><span class="sxs-lookup"><span data-stu-id="dcdac-226">Resource</span></span> | `{ "1":1234, "status":"pending"... }` |
| <span data-ttu-id="dcdac-227">Identidade</span><span class="sxs-lookup"><span data-stu-id="dcdac-227">Identity</span></span> | <span data-ttu-id="dcdac-228">URL</span><span class="sxs-lookup"><span data-stu-id="dcdac-228">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="dcdac-229">Entidades filho</span><span class="sxs-lookup"><span data-stu-id="dcdac-229">Child entities</span></span> | <span data-ttu-id="dcdac-230">Links</span><span class="sxs-lookup"><span data-stu-id="dcdac-230">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="dcdac-231">Atualizar objetos de valor</span><span class="sxs-lookup"><span data-stu-id="dcdac-231">Update value objects</span></span> | <span data-ttu-id="dcdac-232">PUT ou PATCH</span><span class="sxs-lookup"><span data-stu-id="dcdac-232">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="dcdac-233">Repositório</span><span class="sxs-lookup"><span data-stu-id="dcdac-233">Repository</span></span> | <span data-ttu-id="dcdac-234">Coleção</span><span class="sxs-lookup"><span data-stu-id="dcdac-234">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |

## <a name="api-versioning"></a><span data-ttu-id="dcdac-235">Controle de versão de API</span><span class="sxs-lookup"><span data-stu-id="dcdac-235">API versioning</span></span>

<span data-ttu-id="dcdac-236">Uma API é um contrato entre um serviço e os clientes ou os consumidores do serviço.</span><span class="sxs-lookup"><span data-stu-id="dcdac-236">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="dcdac-237">Se uma API for alterada, haverá o risco de interromper clientes que dependem da API, sejam eles clientes externos ou de outros microsserviços.</span><span class="sxs-lookup"><span data-stu-id="dcdac-237">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="dcdac-238">Portanto, é uma boa ideia minimizar a quantidade de alterações de API que você faz.</span><span class="sxs-lookup"><span data-stu-id="dcdac-238">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="dcdac-239">Geralmente, as alterações na implementação subjacente não exigem nenhum alteração na API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-239">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="dcdac-240">No entanto, de modo realista, em algum momento você desejará adicionar novos recursos ou novas capacidades que exigem a alteração de uma API existente.</span><span class="sxs-lookup"><span data-stu-id="dcdac-240">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="dcdac-241">Sempre que possível, torne as alterações na API compatíveis com as versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="dcdac-241">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="dcdac-242">Por exemplo, evite remover um campo de um modelo, uma vez que isso pode interromper os clientes que esperam que o campo exista.</span><span class="sxs-lookup"><span data-stu-id="dcdac-242">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="dcdac-243">A adição de um campo não interrompe a compatibilidade, visto que os clientes devem ignorar todos os campos que não compreendem em uma resposta.</span><span class="sxs-lookup"><span data-stu-id="dcdac-243">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="dcdac-244">No entanto, o serviço deve tratar o caso em que um cliente mais antigo omite o novo campo em uma solicitação.</span><span class="sxs-lookup"><span data-stu-id="dcdac-244">However, the service must handle the case where an older client omits the new field in a request.</span></span>

<span data-ttu-id="dcdac-245">Suporte para o controle de versão em seu contrato de API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-245">Support versioning in your API contract.</span></span> <span data-ttu-id="dcdac-246">Se você fizer uma alteração de API de interrupção, apresente uma nova versão de API.</span><span class="sxs-lookup"><span data-stu-id="dcdac-246">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="dcdac-247">Continue a oferecer suporte à versão anterior e permita que os clientes selecionem qual versão será chamada.</span><span class="sxs-lookup"><span data-stu-id="dcdac-247">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="dcdac-248">Há algumas maneiras de fazer isso.</span><span class="sxs-lookup"><span data-stu-id="dcdac-248">There are a couple of ways to do this.</span></span> <span data-ttu-id="dcdac-249">Uma delas é expor as duas versões no mesmo serviço.</span><span class="sxs-lookup"><span data-stu-id="dcdac-249">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="dcdac-250">Outra opção é executar as duas versões do serviço lado a lado e rotear as solicitações para uma versão ou para a outra com base nas regras de roteamento de HTTP.</span><span class="sxs-lookup"><span data-stu-id="dcdac-250">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span>

![Controle de versão](./images/versioning1.svg)

<span data-ttu-id="dcdac-252">Há um custo para dar suporte a várias versões em termos de tempo de desenvolvedor, de teste e de sobrecarga operacional.</span><span class="sxs-lookup"><span data-stu-id="dcdac-252">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="dcdac-253">Portanto, é conveniente substituir versões antigas o mais rápido possível.</span><span class="sxs-lookup"><span data-stu-id="dcdac-253">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="dcdac-254">Para as APIs internas, a equipe que tem a API pode trabalhar com outras equipes para ajudá-las a migrar para a nova versão.</span><span class="sxs-lookup"><span data-stu-id="dcdac-254">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="dcdac-255">Isso deve ser feito quando for útil ter um processo de controle de várias equipes.</span><span class="sxs-lookup"><span data-stu-id="dcdac-255">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="dcdac-256">Para as APIs externas (públicas), poderá ser mais difícil substituir uma versão de API, especialmente se a API for consumida por terceiros ou por aplicativos cliente nativos.</span><span class="sxs-lookup"><span data-stu-id="dcdac-256">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span>

<span data-ttu-id="dcdac-257">Quando uma implementação de serviço for alterada, será útil marcar a alteração com uma versão.</span><span class="sxs-lookup"><span data-stu-id="dcdac-257">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="dcdac-258">A versão fornece informações importantes ao solucionar problemas de erros.</span><span class="sxs-lookup"><span data-stu-id="dcdac-258">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="dcdac-259">Ela pode ser muito útil para a análise da causa raiz saber exatamente qual versão do serviço foi chamada.</span><span class="sxs-lookup"><span data-stu-id="dcdac-259">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="dcdac-260">Considere o uso do [controle de versão semântico](https://semver.org/) para versões de serviço.</span><span class="sxs-lookup"><span data-stu-id="dcdac-260">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="dcdac-261">O controle de versão semântico usa um formato *MAJOR.MINOR.PATCH*.</span><span class="sxs-lookup"><span data-stu-id="dcdac-261">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="dcdac-262">No entanto, os clientes deverão selecionar somente uma API com o número de versão principal ou, possivelmente, a versão secundária se houver alterações significativas (mas não interruptivas) entre as versões secundárias.</span><span class="sxs-lookup"><span data-stu-id="dcdac-262">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="dcdac-263">Em outras palavras, é razoável para os clientes selecionar entre a versão 1 e a versão 2 de uma API, mas não é coerente selecionar a versão 2.1.3.</span><span class="sxs-lookup"><span data-stu-id="dcdac-263">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="dcdac-264">Se permitir esse nível de granularidade, você correrá o risco de ter que dar suporte à proliferação de versões.</span><span class="sxs-lookup"><span data-stu-id="dcdac-264">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span>

<span data-ttu-id="dcdac-265">Para obter mais informações sobre o controle de versão de API, consulte [Controlando a versão de uma API da Web RESTful](../best-practices/api-design.md#versioning-a-restful-web-api).</span><span class="sxs-lookup"><span data-stu-id="dcdac-265">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="dcdac-266">Ingestão de dados e fluxo de trabalho</span><span class="sxs-lookup"><span data-stu-id="dcdac-266">Ingestion and workflow</span></span>](./ingestion-workflow.md)
