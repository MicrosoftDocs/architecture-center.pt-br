---
title: Ingestão e fluxo de trabalho em microsserviços
description: Ingestão e fluxo de trabalho em microsserviços
author: MikeWasson
ms.date: 10/23/2018
ms.openlocfilehash: 8a6d2d3209ca61e0588c96ed92862c1a7b91109f
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/08/2019
ms.locfileid: "54112795"
---
# <a name="designing-microservices-ingestion-and-workflow"></a><span data-ttu-id="45c91-103">Como criar microsserviços: Ingestão de dados e fluxo de trabalho</span><span class="sxs-lookup"><span data-stu-id="45c91-103">Designing microservices: Ingestion and workflow</span></span>

<span data-ttu-id="45c91-104">Os microsserviços normalmente têm um fluxo de trabalho que abrange vários serviços para uma única transação.</span><span class="sxs-lookup"><span data-stu-id="45c91-104">Microservices often have a workflow that spans multiple services for a single transaction.</span></span> <span data-ttu-id="45c91-105">O fluxo de trabalho deve ser confiável; ele não pode perder transações nem deixá-las em um estado parcialmente concluído.</span><span class="sxs-lookup"><span data-stu-id="45c91-105">The workflow must be reliable; it can't lose transactions or leave them in a partially completed state.</span></span> <span data-ttu-id="45c91-106">Além disso, o controle da taxa de ingestão de solicitações de entrada é algo crítico.</span><span class="sxs-lookup"><span data-stu-id="45c91-106">It's also critical to control the ingestion rate of incoming requests.</span></span> <span data-ttu-id="45c91-107">Com muitos serviços pequenos comunicando-se entre si, um grande volume de solicitações de entrada pode sobrecarregar a comunicação entre os serviços.</span><span class="sxs-lookup"><span data-stu-id="45c91-107">With many small services communicating with each other, a burst of incoming requests can overwhelm the interservice communication.</span></span>

![Diagrama do fluxo de trabalho de ingestão](./images/ingestion-workflow.png)

## <a name="the-drone-delivery-workflow"></a><span data-ttu-id="45c91-109">O fluxo de trabalho da entrega por drone</span><span class="sxs-lookup"><span data-stu-id="45c91-109">The drone delivery workflow</span></span>

<span data-ttu-id="45c91-110">No aplicativo de entrega por drone, as seguintes operações devem ser executadas para o agendamento de uma entrega:</span><span class="sxs-lookup"><span data-stu-id="45c91-110">In the Drone Delivery application, the following operations must be performed to schedule a delivery:</span></span>

1. <span data-ttu-id="45c91-111">Verificar o status da conta do cliente (serviço de Conta).</span><span class="sxs-lookup"><span data-stu-id="45c91-111">Check the status of the customer's account (Account service).</span></span>
2. <span data-ttu-id="45c91-112">Criar uma nova entidade de pacote (serviço de Pacote).</span><span class="sxs-lookup"><span data-stu-id="45c91-112">Create a new package entity (Package service).</span></span>
3. <span data-ttu-id="45c91-113">Verificar se é necessário algum serviço de transporte terceirizado para a entrega, de acordo com os locais da retirada e da entrega (serviço de Transporte terceirizado).</span><span class="sxs-lookup"><span data-stu-id="45c91-113">Check whether any third-party transportation is required for this delivery, based on the pickup and delivery locations (Third-party Transportation service).</span></span>
4. <span data-ttu-id="45c91-114">Agendar um drone para a retirada (serviço de Drone).</span><span class="sxs-lookup"><span data-stu-id="45c91-114">Schedule a drone for pickup (Drone service).</span></span>
5. <span data-ttu-id="45c91-115">Criar uma nova entidade de entrega (serviço de Entrega).</span><span class="sxs-lookup"><span data-stu-id="45c91-115">Create a new delivery entity (Delivery service).</span></span>

<span data-ttu-id="45c91-116">Essa é a essência do aplicativo inteiro, portanto o processo todo deve ter alto desempenho e ser confiável.</span><span class="sxs-lookup"><span data-stu-id="45c91-116">This is the core of the entire application, so the end-to-end process must be performant as well as reliable.</span></span> <span data-ttu-id="45c91-117">Alguns desafios específicos devem ser tratados:</span><span class="sxs-lookup"><span data-stu-id="45c91-117">Some particular challenges must be addressed:</span></span>

- <span data-ttu-id="45c91-118">**Nivelamento de carga**.</span><span class="sxs-lookup"><span data-stu-id="45c91-118">**Load leveling**.</span></span> <span data-ttu-id="45c91-119">O excesso de solicitações de clientes pode sobrecarregar o sistema com o tráfego de rede entre os serviços.</span><span class="sxs-lookup"><span data-stu-id="45c91-119">Too many client requests can overwhelm the system with interservice network traffic.</span></span> <span data-ttu-id="45c91-120">Isso também pode sobrecarregar as dependências de back-end, como os serviços de armazenamento ou remotos.</span><span class="sxs-lookup"><span data-stu-id="45c91-120">It can also overwhelm backend dependencies such as storage or remote services.</span></span> <span data-ttu-id="45c91-121">Isso pode ocasionar a limitação dos serviços realizando as chamadas, o que cria pressão de retorno no sistema.</span><span class="sxs-lookup"><span data-stu-id="45c91-121">These may react by throttling the services calling them, creating backpressure in the system.</span></span> <span data-ttu-id="45c91-122">Portanto, é importante nivelar a carga das solicitações que chegam ao sistema, armazenando-as em buffer ou colocando-as em fila para processamento.</span><span class="sxs-lookup"><span data-stu-id="45c91-122">Therefore, it's important to load level the requests coming into the system, by putting them into a buffer or queue for processing.</span></span>

- <span data-ttu-id="45c91-123">**Entrega garantida**.</span><span class="sxs-lookup"><span data-stu-id="45c91-123">**Guaranteed delivery**.</span></span> <span data-ttu-id="45c91-124">Para evitar a remoção de solicitações de clientes, o componente de ingestão deverá assegurar a entrega de mensagens pelo menos uma vez.</span><span class="sxs-lookup"><span data-stu-id="45c91-124">To avoid dropping any client requests, the ingestion component must guarantee at-least-once delivery of messages.</span></span>

- <span data-ttu-id="45c91-125">**Manipulação de erros**.</span><span class="sxs-lookup"><span data-stu-id="45c91-125">**Error handling**.</span></span> <span data-ttu-id="45c91-126">Se algum dos serviços retornar um código de erro ou apresentar uma falha não transitória, a entrega não poderá ser agendada.</span><span class="sxs-lookup"><span data-stu-id="45c91-126">If any of the services returns an error code or experiences a non-transient failure, the delivery cannot be scheduled.</span></span> <span data-ttu-id="45c91-127">Um código de erro pode indicar uma condição de erro esperada (por exemplo, a conta do cliente está suspensa) ou um erro de servidor inesperado (HTTP 5xx).</span><span class="sxs-lookup"><span data-stu-id="45c91-127">An error code might indicate an expected error condition (for example, the customer's account is suspended) or an unexpected server error (HTTP 5xx).</span></span> <span data-ttu-id="45c91-128">Há também a possibilidade de um serviço não estar disponível, fazendo com que a chamada de rede atinja o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="45c91-128">A service might also be unavailable, causing the network call to time out.</span></span>

<span data-ttu-id="45c91-129">Em primeiro lugar, examinaremos o lado da ingestão da equação: como o sistema pode ingerir solicitações de entrada do usuário com alta produtividade.</span><span class="sxs-lookup"><span data-stu-id="45c91-129">First we'll look at the ingestion side of the equation &mdash; how the system can ingest incoming user requests at high throughput.</span></span> <span data-ttu-id="45c91-130">Em seguida, consideraremos como o aplicativo de entrega por drone pode implementar um fluxo de trabalho confiável.</span><span class="sxs-lookup"><span data-stu-id="45c91-130">Then we'll consider how the drone delivery application can implement a reliable workflow.</span></span> <span data-ttu-id="45c91-131">Na verdade, o design do subsistema de ingestão afeta o back-end do fluxo de trabalho.</span><span class="sxs-lookup"><span data-stu-id="45c91-131">It turns out that the design of the ingestion subsystem affects the workflow backend.</span></span>

## <a name="ingestion"></a><span data-ttu-id="45c91-132">Ingestão</span><span class="sxs-lookup"><span data-stu-id="45c91-132">Ingestion</span></span>

<span data-ttu-id="45c91-133">Com base nos requisitos comerciais, a equipe de desenvolvimento identificou os seguintes requisitos não funcionais para a ingestão:</span><span class="sxs-lookup"><span data-stu-id="45c91-133">Based on business requirements, the development team identified the following non-functional requirements for ingestion:</span></span>

- <span data-ttu-id="45c91-134">Produtividade constante de 10 mil solicitações/s.</span><span class="sxs-lookup"><span data-stu-id="45c91-134">Sustained throughput of 10K requests/sec.</span></span>
- <span data-ttu-id="45c91-135">Capacidade de lidar com picos de até 50 mil/s sem remover solicitações de cliente nem atingir o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="45c91-135">Able to handle spikes of up to 50K/sec without dropping client requests or timing out.</span></span>
- <span data-ttu-id="45c91-136">Latência inferior a 500 ms em 99% do tempo.</span><span class="sxs-lookup"><span data-stu-id="45c91-136">Less than 500ms latency in the 99th percentile.</span></span>

<span data-ttu-id="45c91-137">O requisito para lidar com picos ocasionais de tráfego apresenta um desafio de design.</span><span class="sxs-lookup"><span data-stu-id="45c91-137">The requirement to handle occasional spikes in traffic presents a design challenge.</span></span> <span data-ttu-id="45c91-138">Em teoria, o sistema pode ser escalado horizontalmente para manipular o tráfego máximo esperado.</span><span class="sxs-lookup"><span data-stu-id="45c91-138">In theory, the system could be scaled out to handle the maximum expected traffic.</span></span> <span data-ttu-id="45c91-139">No entanto, provisionar uma quantidade tão grande de recursos como essa seria muito ineficiente.</span><span class="sxs-lookup"><span data-stu-id="45c91-139">However, provisioning that many resources would be very inefficient.</span></span> <span data-ttu-id="45c91-140">Na maioria das vezes, o aplicativo não precisará dessa capacidade, portanto haverá núcleos ociosos custando dinheiro sem adicionar valor.</span><span class="sxs-lookup"><span data-stu-id="45c91-140">Most of the time, the application will not need that much capacity, so there would be idle cores, costing money without adding value.</span></span>

<span data-ttu-id="45c91-141">Uma abordagem melhor é colocar as solicitações de entrada em um buffer e deixá-lo atuar como um nivelador de carga.</span><span class="sxs-lookup"><span data-stu-id="45c91-141">A better approach is to put the incoming requests into a buffer, and let the buffer act as a load leveler.</span></span> <span data-ttu-id="45c91-142">Com esse design, o serviço de Ingestão deve lidar com a taxa máxima de ingestão em curtos períodos, mas os serviços de back-end precisam apenas lidar com a carga constante máxima.</span><span class="sxs-lookup"><span data-stu-id="45c91-142">With this design, the Ingestion service must be able to handle the maximum ingestion rate over short periods, but the backend services only need to handle the maximum sustained load.</span></span> <span data-ttu-id="45c91-143">Ao armazenar em buffer no front-end, os serviços de back-end não precisarão lidar com grandes picos no tráfego.</span><span class="sxs-lookup"><span data-stu-id="45c91-143">By buffering at the front end, the backend services shouldn't need to handle large spikes in traffic.</span></span> <span data-ttu-id="45c91-144">Na escala necessária para o aplicativo de entrega por drone, os [Hubs de Eventos do Azure](/azure/event-hubs/) é uma boa escolha para o nivelamento de carga.</span><span class="sxs-lookup"><span data-stu-id="45c91-144">At the scale required for the Drone Delivery application, [Azure Event Hubs](/azure/event-hubs/) is a good choice for load leveling.</span></span> <span data-ttu-id="45c91-145">Os Hubs de Eventos oferecem baixa latência e alta produtividade, além de ser uma solução econômica em altos volumes de ingestão.</span><span class="sxs-lookup"><span data-stu-id="45c91-145">Event Hubs offers low latency and high throughput, and is a cost effective solution at high ingestion volumes.</span></span>

<span data-ttu-id="45c91-146">Para nossos testes, usamos um hub de eventos da camada Standard com 32 partições e 100 unidades de produtividade.</span><span class="sxs-lookup"><span data-stu-id="45c91-146">For our testing, we used a Standard tier event hub with 32 partitions and 100 throughput units.</span></span> <span data-ttu-id="45c91-147">Observamos uma ingestão de aproximadamente 32 mil eventos por segundo, com latência de 90 ms.</span><span class="sxs-lookup"><span data-stu-id="45c91-147">We observed about 32K events / second ingestion, with latency around 90ms.</span></span> <span data-ttu-id="45c91-148">No momento, o limite padrão é de 20 unidades de produtividade, mas os clientes do Azure podem solicitar unidades de produtividade adicionais por meio de uma solicitação de suporte.</span><span class="sxs-lookup"><span data-stu-id="45c91-148">Currently the default limit is 20 throughput units, but Azure customers can request additional throughput units by filing a support request.</span></span> <span data-ttu-id="45c91-149">Veja [Cotas de Hubs de Eventos](/azure/event-hubs/event-hubs-quotas) para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="45c91-149">See [Event Hubs quotas](/azure/event-hubs/event-hubs-quotas) for more information.</span></span> <span data-ttu-id="45c91-150">Como em todas as métricas de desempenho, muitos fatores podem afetar o desempenho, como o tamanho do conteúdo da mensagem, portanto não interprete esses números como um parâmetro de comparação.</span><span class="sxs-lookup"><span data-stu-id="45c91-150">As with all performance metrics, many factors can affect performance, such as message payload size, so don't interpret these numbers as a benchmark.</span></span> <span data-ttu-id="45c91-151">Se uma produtividade maior for necessária, o serviço de Ingestão poderá ser fragmentado em mais de um hub de eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-151">If more throughput is needed, the Ingestion service can shard across more than one event hub.</span></span> <span data-ttu-id="45c91-152">Para taxas de produtividade ainda maiores, os [Hubs de Eventos Dedicados](/azure/event-hubs/event-hubs-dedicated-overview) oferecem implantações de locatário único para a entrada de mais de 2 milhões de eventos por segundo.</span><span class="sxs-lookup"><span data-stu-id="45c91-152">For even higher throughput rates, [Event Hubs Dedicated](/azure/event-hubs/event-hubs-dedicated-overview) offers single-tenant deployments that can ingress over 2 million events per second.</span></span>

<span data-ttu-id="45c91-153">É importante entender como os Hubs de Eventos podem alcançar uma produtividade tão alta, porque isso afeta como um cliente deve consumir as mensagens dos Hubs de Eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-153">It's important to understand how Event Hubs can achieve such high throughput, because that affects how a client should consume messages from Event Hubs.</span></span> <span data-ttu-id="45c91-154">Os Hubs de Eventos não implementam uma *fila*.</span><span class="sxs-lookup"><span data-stu-id="45c91-154">Event Hubs does not implement a *queue*.</span></span> <span data-ttu-id="45c91-155">Em vez disso, eles implementam um *fluxo de eventos*.</span><span class="sxs-lookup"><span data-stu-id="45c91-155">Rather, it implements an *event stream*.</span></span>

<span data-ttu-id="45c91-156">Com uma fila, um consumidor individual poderá remover uma mensagem da fila e o próximo consumidor não verá essa mensagem.</span><span class="sxs-lookup"><span data-stu-id="45c91-156">With a queue, an individual consumer can remove a message from the queue, and the next consumer won't see that message.</span></span> <span data-ttu-id="45c91-157">As filas, portanto, permitem que você use um [Padrão de consumidores concorrentes](../patterns/competing-consumers.md) para processar mensagens em paralelo e melhorar a escalabilidade.</span><span class="sxs-lookup"><span data-stu-id="45c91-157">Queues therefore allow you to use a [Competing Consumers pattern](../patterns/competing-consumers.md) to process messages in parallel and improve scalability.</span></span> <span data-ttu-id="45c91-158">Para maior resiliência, o consumidor mantém um bloqueio na mensagem e libera-o quando termina de processá-la.</span><span class="sxs-lookup"><span data-stu-id="45c91-158">For greater resiliency, the consumer holds a lock on the message and releases the lock when it's done processing the message.</span></span> <span data-ttu-id="45c91-159">Se o consumidor falhar, por exemplo, por causa de uma falha no nó em que ele é executado, o bloqueio atingirá o tempo limite e a mensagem voltará à fila.</span><span class="sxs-lookup"><span data-stu-id="45c91-159">If the consumer fails &mdash; for example, the node it's running on crashes &mdash; the lock times out and the message goes back onto the queue.</span></span>

![Diagrama de semântica de fila](./images/queue-semantics.png)

<span data-ttu-id="45c91-161">Os Hubs de Eventos, por outro lado, usam a semântica de streaming.</span><span class="sxs-lookup"><span data-stu-id="45c91-161">Event Hubs, on the other hand, uses streaming semantics.</span></span> <span data-ttu-id="45c91-162">Os consumidores leem o fluxo de forma independente em seu próprio ritmo.</span><span class="sxs-lookup"><span data-stu-id="45c91-162">Consumers read the stream independently at their own pace.</span></span> <span data-ttu-id="45c91-163">Cada consumidor é responsável por manter o controle da sua posição atual no fluxo.</span><span class="sxs-lookup"><span data-stu-id="45c91-163">Each consumer is responsible for keeping track of its current position in the stream.</span></span> <span data-ttu-id="45c91-164">Um consumidor deve gravar sua posição atual no armazenamento persistente em um intervalo predefinido.</span><span class="sxs-lookup"><span data-stu-id="45c91-164">A consumer should write its current position to persistent storage at some predefined interval.</span></span> <span data-ttu-id="45c91-165">Dessa forma, se o consumidor apresentar uma falha (por exemplo, falhas do consumidor ou do host), uma nova instância poderá retomar a leitura do fluxo da última posição gravada.</span><span class="sxs-lookup"><span data-stu-id="45c91-165">That way, if the consumer experiences a fault (for example, the consumer crashes, or the host fails), then a new instance can resume reading the stream from the last recorded position.</span></span> <span data-ttu-id="45c91-166">Esse processo é chamado *ponto de verificação*.</span><span class="sxs-lookup"><span data-stu-id="45c91-166">This process is called *checkpointing*.</span></span>

<span data-ttu-id="45c91-167">Por motivos de desempenho, um consumidor normalmente não realiza o ponto de verificação depois de cada mensagem.</span><span class="sxs-lookup"><span data-stu-id="45c91-167">For performance reasons, a consumer generally doesn't checkpoint after each message.</span></span> <span data-ttu-id="45c91-168">Em vez disso, realiza o ponto de verificação em um intervalo fixo, por exemplo, depois de processar *n* mensagens ou a cada *n* segundos.</span><span class="sxs-lookup"><span data-stu-id="45c91-168">Instead, it checkpoints at some fixed interval, for example after processing *n* messages, or every *n* seconds.</span></span> <span data-ttu-id="45c91-169">Como consequência, se um consumidor falhar, alguns eventos poderão ser processados duas vezes, porque uma nova instância sempre continuará do último ponto de verificação.</span><span class="sxs-lookup"><span data-stu-id="45c91-169">As a consequence, if a consumer fails, some events may get processed twice, because a new instance always picks up from the last checkpoint.</span></span> <span data-ttu-id="45c91-170">Há dois lados da mesma moeda: os pontos de verificação frequentes podem prejudicar o desempenho, mas os pontos de verificação esparsos significam que você reproduzirá mais eventos após uma falha.</span><span class="sxs-lookup"><span data-stu-id="45c91-170">There is a tradeoff: Frequent checkpoints can hurt performance, but sparse checkpoints mean you will replay more events after a failure.</span></span>

![Diagrama da semântica do fluxo](./images/stream-semantics.png)

<span data-ttu-id="45c91-172">Os Hubs de Eventos não são projetados para consumidores concorrentes.</span><span class="sxs-lookup"><span data-stu-id="45c91-172">Event Hubs is not designed for competing consumers.</span></span> <span data-ttu-id="45c91-173">Embora vários consumidores possam ler um fluxo, cada um deles percorre-o de forma independente.</span><span class="sxs-lookup"><span data-stu-id="45c91-173">Although multiple consumers can read a stream, each traverses the stream independently.</span></span> <span data-ttu-id="45c91-174">Em vez disso, os Hubs de Eventos usam um padrão de consumidor particionado.</span><span class="sxs-lookup"><span data-stu-id="45c91-174">Instead, Event Hubs uses a partitioned consumer pattern.</span></span> <span data-ttu-id="45c91-175">Um hub de eventos tem até 32 partições.</span><span class="sxs-lookup"><span data-stu-id="45c91-175">An event hub has up to 32 partitions.</span></span> <span data-ttu-id="45c91-176">A escala horizontal é obtida atribuindo um consumidor separado a cada partição.</span><span class="sxs-lookup"><span data-stu-id="45c91-176">Horizontal scale is achieved by assigning a separate consumer to each partition.</span></span>

<span data-ttu-id="45c91-177">O que isso significa para o fluxo de trabalho da entrega por drone?</span><span class="sxs-lookup"><span data-stu-id="45c91-177">What does this mean for the drone delivery workflow?</span></span> <span data-ttu-id="45c91-178">Para obter todos os benefícios dos Hubs de Eventos, o Agendador de Entregas não pode esperar o processamento de cada mensagem antes de passar para a próxima.</span><span class="sxs-lookup"><span data-stu-id="45c91-178">To get the full benefit of Event Hubs, the Delivery Scheduler cannot wait for each message to be processed before moving onto the next.</span></span> <span data-ttu-id="45c91-179">Se fizer isso, passará a maior parte do tempo aguardando a conclusão das chamadas de rede.</span><span class="sxs-lookup"><span data-stu-id="45c91-179">If it does that, it will spend most of its time waiting for network calls to complete.</span></span> <span data-ttu-id="45c91-180">Em vez disso, ele precisa processar lotes de mensagens em paralelo, usando chamadas assíncronas aos serviços de back-end.</span><span class="sxs-lookup"><span data-stu-id="45c91-180">Instead, it needs to process batches of messages in parallel, using asynchronous calls to the backend services.</span></span> <span data-ttu-id="45c91-181">Como veremos, escolher a estratégia de ponto de verificação correta também é importante.</span><span class="sxs-lookup"><span data-stu-id="45c91-181">As we'll see, choosing the right checkpointing strategy is also important.</span></span>

## <a name="workflow"></a><span data-ttu-id="45c91-182">Fluxo de trabalho</span><span class="sxs-lookup"><span data-stu-id="45c91-182">Workflow</span></span>

<span data-ttu-id="45c91-183">Analisamos três opções para ler e processar as mensagens: o Host do Processador de Eventos, as filas de Barramento de Serviço e a biblioteca do IoTHub React.</span><span class="sxs-lookup"><span data-stu-id="45c91-183">We looked at three options for reading and processing the messages: Event Processor Host, Service Bus queues, and the IoTHub React library.</span></span> <span data-ttu-id="45c91-184">Escolhemos o IoTHub React, mas para entender o porquê, será mais fácil começar pelo Host do Processador de Eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-184">We chose IoTHub React, but to understand why, it helps to start with Event Processor Host.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="45c91-185">Host do processador de eventos</span><span class="sxs-lookup"><span data-stu-id="45c91-185">Event Processor Host</span></span>

<span data-ttu-id="45c91-186">O Host do Processador de Eventos foi projetado para o envio em lote de mensagens.</span><span class="sxs-lookup"><span data-stu-id="45c91-186">Event Processor Host is designed for message batching.</span></span> <span data-ttu-id="45c91-187">O aplicativo implementa a interface `IEventProcessor` e o Host do Processador cria uma instância do processador de eventos para cada partição no hub de eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-187">The application implements the `IEventProcessor` interface, and the Processor Host creates one event processor instance for each partition in the event hub.</span></span> <span data-ttu-id="45c91-188">Em seguida, o Host do Processador de Eventos chama cada método `ProcessEventsAsync` do processador de eventos com lotes de mensagens de eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-188">The Event Processor Host then calls each event processor's `ProcessEventsAsync` method with batches of event messages.</span></span> <span data-ttu-id="45c91-189">O aplicativo controla quando realizar o ponto de verificação no método `ProcessEventsAsync` e o Host do Processador de Eventos grava os pontos de verificação no armazenamento do Azure.</span><span class="sxs-lookup"><span data-stu-id="45c91-189">The application controls when to checkpoint inside the `ProcessEventsAsync` method, and the Event Processor Host writes the checkpoints to Azure storage.</span></span>

<span data-ttu-id="45c91-190">Em uma partição, o Host do Processador de Eventos espera que `ProcessEventsAsync` seja retornado antes de chamar novamente o próximo lote.</span><span class="sxs-lookup"><span data-stu-id="45c91-190">Within a partition, Event Processor Host waits for `ProcessEventsAsync` to return before calling again with the next batch.</span></span> <span data-ttu-id="45c91-191">Essa abordagem simplifica o modelo de programação, uma vez que o código de processamento de eventos não precisa ser reentrante.</span><span class="sxs-lookup"><span data-stu-id="45c91-191">This approach simplifies the programming model, because your event processing code doesn't need to be reentrant.</span></span> <span data-ttu-id="45c91-192">No entanto, isso também significa que o processador de eventos manipula um lote por vez e isso limita a velocidade de envio de mensagens do Host do Processador.</span><span class="sxs-lookup"><span data-stu-id="45c91-192">However, it also means that the event processor handles one batch at a time, and this gates the speed at which the Processor Host can pump messages.</span></span>

> [!NOTE]
> <span data-ttu-id="45c91-193">O Host do Processador não *espera* no sentido de bloquear um thread.</span><span class="sxs-lookup"><span data-stu-id="45c91-193">The Processor Host doesn't actually *wait* in the sense of blocking a thread.</span></span> <span data-ttu-id="45c91-194">O método `ProcessEventsAsync` é assíncrono, portanto o Host do Processador poderá executar outras tarefas enquanto o método estiver sendo concluído.</span><span class="sxs-lookup"><span data-stu-id="45c91-194">The `ProcessEventsAsync` method is asynchronous, so the Processor Host can do other work while the method is completing.</span></span> <span data-ttu-id="45c91-195">No entanto, ele não entregará outro lote de mensagens para essa partição até o método ser retornado.</span><span class="sxs-lookup"><span data-stu-id="45c91-195">But it won't deliver another batch of messages for that partition until the method returns.</span></span>

<span data-ttu-id="45c91-196">No aplicativo de entrega por drone, um lote de mensagens pode ser processado em paralelo.</span><span class="sxs-lookup"><span data-stu-id="45c91-196">In the drone application, a batch of messages can be processed in parallel.</span></span> <span data-ttu-id="45c91-197">No entanto, esperar a conclusão de um lote inteiro ainda poderá causar um gargalo.</span><span class="sxs-lookup"><span data-stu-id="45c91-197">But waiting for the whole batch to complete can still cause a bottleneck.</span></span> <span data-ttu-id="45c91-198">A velocidade de processamento depende da mensagem mais lenta no lote.</span><span class="sxs-lookup"><span data-stu-id="45c91-198">Processing can only be as fast as the slowest message within a batch.</span></span> <span data-ttu-id="45c91-199">Qualquer variação de tempos de resposta pode criar uma espera longa, em que algumas respostas lentas retardam todo o sistema.</span><span class="sxs-lookup"><span data-stu-id="45c91-199">Any variation in response times can create a "long tail," where a few slow responses drag down the entire system.</span></span> <span data-ttu-id="45c91-200">Nossos testes de desempenho mostraram que não alcançamos nossa meta de produtividade usando essa abordagem.</span><span class="sxs-lookup"><span data-stu-id="45c91-200">Our performance tests showed that we did not achieve our target throughput using this approach.</span></span> <span data-ttu-id="45c91-201">Isso *não* significa que você deva evitar usar o Host do Processador de Eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-201">This does *not* mean that you should avoid using Event Processor Host.</span></span> <span data-ttu-id="45c91-202">No entanto, para obter alta produtividade, evite tarefas de longa execução no método `ProcesssEventsAsync`.</span><span class="sxs-lookup"><span data-stu-id="45c91-202">But for high throughput, avoid doing any long-running tasks inside the `ProcesssEventsAsync` method.</span></span> <span data-ttu-id="45c91-203">Processe cada lote rapidamente.</span><span class="sxs-lookup"><span data-stu-id="45c91-203">Process each batch quickly.</span></span>

### <a name="iothub-react"></a><span data-ttu-id="45c91-204">IoTHub React</span><span class="sxs-lookup"><span data-stu-id="45c91-204">IotHub React</span></span>

<span data-ttu-id="45c91-205">O [IoTHub React](https://github.com/Azure/toketi-iothubreact) é uma biblioteca do Akka Streams para a leitura de eventos do Hub de Eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-205">[IotHub React](https://github.com/Azure/toketi-iothubreact) is an Akka Streams library for reading events from Event Hub.</span></span> <span data-ttu-id="45c91-206">O Akka Streams é uma estrutura de programação baseada em fluxo que implementa a especificação [Reactive Streams](https://www.reactive-streams.org/).</span><span class="sxs-lookup"><span data-stu-id="45c91-206">Akka Streams is a stream-based programming framework that implements the [Reactive Streams](https://www.reactive-streams.org/) specification.</span></span> <span data-ttu-id="45c91-207">Ele fornece uma maneira de criar pipelines de streaming eficientes, em que todas as operações de streaming são executadas de maneira assíncrona e o pipeline manipula normalmente a pressão de retorno.</span><span class="sxs-lookup"><span data-stu-id="45c91-207">It provides a way to build efficient streaming pipelines, where all streaming operations are performed asynchronously, and the pipeline gracefully handles backpressure.</span></span> <span data-ttu-id="45c91-208">A pressão de retorno ocorre quando uma origem do evento gera eventos mais rapidamente que os consumidores downstream podem recebê-los, o que ocorre exatamente quando o sistema de entrega por drone tem um pico de tráfego.</span><span class="sxs-lookup"><span data-stu-id="45c91-208">Backpressure occurs when an event source produces events at a faster rate than the downstream consumers can receive them &mdash; which is exactly the situation when the drone delivery system has a spike in traffic.</span></span> <span data-ttu-id="45c91-209">Se os serviços de back-end ficarem mais lentos, o IoTHub React também ficará lento.</span><span class="sxs-lookup"><span data-stu-id="45c91-209">If backend services go slower, IoTHub React will slow down.</span></span> <span data-ttu-id="45c91-210">Se a capacidade for aumentada, o IoTHub React enviará por push mais mensagens pelo pipeline.</span><span class="sxs-lookup"><span data-stu-id="45c91-210">If capacity is increased, IoTHub React will push more messages through the pipeline.</span></span>

<span data-ttu-id="45c91-211">O Akka Streams também é um modelo de programação muito natural para o streaming de eventos dos Hubs de Eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-211">Akka Streams is also a very natural programming model for streaming events from Event Hubs.</span></span> <span data-ttu-id="45c91-212">Em vez de fazer um loop por meio de um lote de eventos, você definirá um conjunto de operações que serão aplicadas a cada evento e deixara que o Akka Streams manipule o streaming.</span><span class="sxs-lookup"><span data-stu-id="45c91-212">Instead of looping through a batch of events, you define a set of operations that will be applied to each event, and let Akka Streams handle the streaming.</span></span> <span data-ttu-id="45c91-213">O Akka Streams define um pipeline de streaming em termos de *Origens*, de *Fluxos* e de *Coletores*.</span><span class="sxs-lookup"><span data-stu-id="45c91-213">Akka Streams defines a streaming pipeline in terms of *Sources*, *Flows*, and *Sinks*.</span></span> <span data-ttu-id="45c91-214">Uma origem gera um fluxo de saída, um fluxo processa um fluxo de entrada e produz um fluxo de saída e um coletor consome um fluxo sem produzir nenhuma saída.</span><span class="sxs-lookup"><span data-stu-id="45c91-214">A source generates an output stream, a flow processes an input stream and produces an output stream, and a sink consumes a stream without producing any output.</span></span>

<span data-ttu-id="45c91-215">Veja abaixo o código no serviço de Agendador que configura o pipeline do Akka Streams:</span><span class="sxs-lookup"><span data-stu-id="45c91-215">Here is the code in the Scheduler service that sets up the Akka Streams pipeline:</span></span>

```java
IoTHub iotHub = new IoTHub();
Source<MessageFromDevice, NotUsed> messages = iotHub.source(options);

messages.map(msg -> DeliveryRequestEventProcessor.parseDeliveryRequest(msg))
        .filter(ad -> ad.getDelivery() != null).via(deliveryProcessor()).to(iotHub.checkpointSink())
        .run(streamMaterializer);
```

<span data-ttu-id="45c91-216">Este código configura os Hubs de Eventos como uma origem.</span><span class="sxs-lookup"><span data-stu-id="45c91-216">This code configures Event Hubs as a source.</span></span> <span data-ttu-id="45c91-217">A instrução `map` desserializa toda mensagem de evento em uma classe Java que representa uma solicitação de entrega.</span><span class="sxs-lookup"><span data-stu-id="45c91-217">The `map` statement deserializes each event message into a Java class that represents a delivery request.</span></span> <span data-ttu-id="45c91-218">A instrução `filter` remove qualquer objeto `null` do fluxo; ela protege nos casos em que uma mensagem não pode ser desserializada.</span><span class="sxs-lookup"><span data-stu-id="45c91-218">The `filter` statement removes any `null` objects from the stream; this guards against the case where a message can't be deserialized.</span></span> <span data-ttu-id="45c91-219">A instrução `via` une a origem a um fluxo que processa cada solicitação de entrega.</span><span class="sxs-lookup"><span data-stu-id="45c91-219">The `via` statement joins the source to a flow that processes each delivery request.</span></span> <span data-ttu-id="45c91-220">O método `to` une o fluxo ao coletor de ponto de verificação, que é inserido no IoTHub React.</span><span class="sxs-lookup"><span data-stu-id="45c91-220">The `to` method joins the flow to the checkpoint sink, which is built into IoTHub React.</span></span>

<span data-ttu-id="45c91-221">O IoTHub React usa uma estratégia de ponto de verificação diferente que a do Host do Processador de Eventos.</span><span class="sxs-lookup"><span data-stu-id="45c91-221">IoTHub React uses a different checkpointing strategy than Event Host Processor.</span></span> <span data-ttu-id="45c91-222">Os pontos de verificação são gravados pelo coletor de ponto de verificação, que é o estágio de encerramento no pipeline.</span><span class="sxs-lookup"><span data-stu-id="45c91-222">Checkpoints are written by the checkpoint sink, which is the terminating stage in the pipeline.</span></span> <span data-ttu-id="45c91-223">O design de Akka Streams permite que o pipeline continue o streaming de dados enquanto o coletor grava o ponto de verificação.</span><span class="sxs-lookup"><span data-stu-id="45c91-223">The design of Akka Streams allows the pipeline to continue streaming data while the sink is writing the checkpoint.</span></span> <span data-ttu-id="45c91-224">Isso significa que os estágios de processamento upstream não precisam esperar que o ponto de verificação ocorra.</span><span class="sxs-lookup"><span data-stu-id="45c91-224">That means the upstream processing stages don't need to wait for checkpointing to happen.</span></span> <span data-ttu-id="45c91-225">Você pode configurar o ponto de verificação para ocorrer após um tempo limite ou após o processamento de um determinado número de mensagens.</span><span class="sxs-lookup"><span data-stu-id="45c91-225">You can configure checkpointing to occur after a timeout or after a certain number of messages have been processed.</span></span>

<span data-ttu-id="45c91-226">O método `deliveryProcessor` cria o fluxo do Akka Streams:</span><span class="sxs-lookup"><span data-stu-id="45c91-226">The `deliveryProcessor` method creates the Akka Streams flow:</span></span>

```java
private static Flow<AkkaDelivery, MessageFromDevice, NotUsed> deliveryProcessor() {
    return Flow.of(AkkaDelivery.class).map(delivery -> {
        CompletableFuture<DeliverySchedule> completableSchedule = DeliveryRequestEventProcessor
                .processDeliveryRequestAsync(delivery.getDelivery(),
                        delivery.getMessageFromDevice().properties());

        completableSchedule.whenComplete((deliverySchedule,error) -> {
            if (error!=null){
                Log.info("failed delivery" + error.getStackTrace());
            }
            else{
                Log.info("Completed Delivery",deliverySchedule.toString());
            }

        });
        completableSchedule = null;
        return delivery.getMessageFromDevice();
    });
}
```

<span data-ttu-id="45c91-227">O fluxo chama um método `processDeliveryRequestAsync` estático que executa o trabalho real do processamento de cada mensagem.</span><span class="sxs-lookup"><span data-stu-id="45c91-227">The flow calls a static `processDeliveryRequestAsync` method that does the actual work of processing each message.</span></span>

### <a name="scaling-with-iothub-react"></a><span data-ttu-id="45c91-228">Dimensionamento com o IoTHub React</span><span class="sxs-lookup"><span data-stu-id="45c91-228">Scaling with IoTHub React</span></span>

<span data-ttu-id="45c91-229">O serviço de Agendador é projetado para que cada instância de contêiner leia de uma única partição.</span><span class="sxs-lookup"><span data-stu-id="45c91-229">The Scheduler service is designed so that each container instance reads from a single partition.</span></span> <span data-ttu-id="45c91-230">Por exemplo, se o Hub de Eventos tiver 32 partições, o serviço de Agendador será implantado com 32 réplicas.</span><span class="sxs-lookup"><span data-stu-id="45c91-230">For example, if the Event Hub has 32 partitions, the Scheduler service is deployed with 32 replicas.</span></span> <span data-ttu-id="45c91-231">Isso permite uma grande flexibilidade em termos de dimensionamento horizontal.</span><span class="sxs-lookup"><span data-stu-id="45c91-231">This allows for a lot of flexibility in terms of horizontal scaling.</span></span>

<span data-ttu-id="45c91-232">Dependendo do tamanho do cluster, um nó no cluster pode ter mais de um pod de serviço de Agendador em execução nele.</span><span class="sxs-lookup"><span data-stu-id="45c91-232">Depending on the size of the cluster, a node in the cluster might have more than one Scheduler service pod running on it.</span></span> <span data-ttu-id="45c91-233">No entanto, se o serviço de Agendador precisar de mais recursos, o cluster poderá ser escalado horizontalmente para distribuir os pods entre mais nós.</span><span class="sxs-lookup"><span data-stu-id="45c91-233">But if the Scheduler service needs more resources, the cluster can be scaled out, in order to distribute the pods across more nodes.</span></span> <span data-ttu-id="45c91-234">Nossos testes de desempenho mostraram que o serviço de Agendador está relacionado à memória e aos threads, portanto o desempenho depende muito do tamanho da VM e do número de pods por nó.</span><span class="sxs-lookup"><span data-stu-id="45c91-234">Our performance tests showed that the Scheduler service is memory- and thread-bound, so performance depended greatly on the VM size and the number of pods per node.</span></span>

<span data-ttu-id="45c91-235">Cada instância precisa saber de qual partição dos Hubs de Eventos deverá ler.</span><span class="sxs-lookup"><span data-stu-id="45c91-235">Each instance needs to know which Event Hubs partition to read from.</span></span> <span data-ttu-id="45c91-236">Para configurar o número de partição, usamos o tipo de recurso [StatefulSet](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/) no Kubernetes.</span><span class="sxs-lookup"><span data-stu-id="45c91-236">To configure the partition number, we took advantage of the [StatefulSet](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/) resource type in Kubernetes.</span></span> <span data-ttu-id="45c91-237">Os pods de um StatefulSet têm um identificador persistente que inclui um índice numérico.</span><span class="sxs-lookup"><span data-stu-id="45c91-237">Pods in a StatefulSet have a persistent identifier that includes a numeric index.</span></span> <span data-ttu-id="45c91-238">Para ser mais específico, o nome do pod é `<statefulset name>-<index>` e esse valor está disponível para o contêiner por meio da [API Downward](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/) do Kubernetes.</span><span class="sxs-lookup"><span data-stu-id="45c91-238">Specifically, the pod name is `<statefulset name>-<index>`, and this value is available to the container through the Kubernetes [Downward API](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/).</span></span> <span data-ttu-id="45c91-239">No tempo de execução, o serviço de Agendador lê o nome do pod e usa o índice do pod como a ID da partição.</span><span class="sxs-lookup"><span data-stu-id="45c91-239">At run time, the Scheduler services reads the pod name and uses the pod index as the partition ID.</span></span>

<span data-ttu-id="45c91-240">Se for necessário expandir o serviço de Agendador ainda mais, você poderá atribuir mais de um pod por partição do hub de eventos, para que vários pods leiam cada partição.</span><span class="sxs-lookup"><span data-stu-id="45c91-240">If you needed to scale out the Scheduler service even further, you could assign more than one pod per event hub partition, so that multiple pods are reading each partition.</span></span> <span data-ttu-id="45c91-241">No entanto, nesse caso, cada instância leria todos os eventos na partição atribuída.</span><span class="sxs-lookup"><span data-stu-id="45c91-241">However, in that case, each instance would read all of the events in the assigned partition.</span></span> <span data-ttu-id="45c91-242">Para evitar o processamento duplicado, use um algoritmo de hash para que cada instância ignore uma parte das mensagens.</span><span class="sxs-lookup"><span data-stu-id="45c91-242">To avoid duplicate processing, you would need to use a hashing algorithm, so that each instance skips over a portion of the messages.</span></span> <span data-ttu-id="45c91-243">Dessa forma, vários leitores poderão consumir o fluxo, mas toda mensagem será processada por apenas uma instância.</span><span class="sxs-lookup"><span data-stu-id="45c91-243">That way, multiple readers can consume the stream, but every message is processed by only one instance.</span></span>

![Diagrama de hash do hub de eventos](./images/eventhub-hashing.png)

### <a name="service-bus-queues"></a><span data-ttu-id="45c91-245">Filas do Barramento de Serviço</span><span class="sxs-lookup"><span data-stu-id="45c91-245">Service Bus queues</span></span>

<span data-ttu-id="45c91-246">Uma terceira opção que consideramos foi copiar mensagens dos Hubs de Eventos para uma fila do Barramento de Serviço e, em seguida, fazer com que o serviço de Agendador lesse as mensagens do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="45c91-246">A third option that we considered was to copy messages from Event Hubs into a Service Bus queue, and then have the Scheduler service read the messages from Service Bus.</span></span> <span data-ttu-id="45c91-247">Pode parecer estranho a gravação de solicitações de entrada nos Hubs de Eventos somente para copiá-las no Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="45c91-247">It might seem strange to writing the incoming requests into Event Hubs only to copy them in Service Bus.</span></span>  <span data-ttu-id="45c91-248">No entanto, a ideia era aproveitar os diferentes pontos fortes de cada serviço: usar os Hubs de Eventos para absorver picos de tráfego intenso e, ao mesmo tempo, aproveitar a semântica de fila no Barramento de Serviço para processar a carga de trabalho com um padrão de consumidores concorrentes.</span><span class="sxs-lookup"><span data-stu-id="45c91-248">However, the idea was to leverage the different strengths of each service: Use Event Hubs to absorb spikes of heavy traffic, while taking advantage of the queue semantics in Service Bus to process the workload with a competing consumers pattern.</span></span> <span data-ttu-id="45c91-249">Lembre-se de que nossa meta para a produtividade constante é menor que a nossa carga de pico esperada, portanto o processamento da fila do Barramento de Serviço não precisaria ser tão rápido quanto a ingestão de mensagem.</span><span class="sxs-lookup"><span data-stu-id="45c91-249">Remember that our target for sustained throughput is less than our expected peak load, so processing the Service Bus queue would not need to be as fast the message ingestion.</span></span>

<span data-ttu-id="45c91-250">Com essa abordagem, nossa implementação de prova de conceito conseguiu aproximadamente 4 mil operações por segundo.</span><span class="sxs-lookup"><span data-stu-id="45c91-250">With this approach, our proof-of-concept implementation achieved about 4K operations per second.</span></span> <span data-ttu-id="45c91-251">Esses testes usaram serviços de back-end fictícios que não fizeram nenhum trabalho real, mas simplesmente adicionaram uma quantidade fixa de latência por serviço.</span><span class="sxs-lookup"><span data-stu-id="45c91-251">These tests used mock backend services that did not do any real work, but simply added a fixed amount of latency per service.</span></span> <span data-ttu-id="45c91-252">Observe que nossos números de desempenho foram muito menores que o máximo teórico do Barramento de Serviço.</span><span class="sxs-lookup"><span data-stu-id="45c91-252">Note that our performance numbers were much less than the theoretical maximum for Service Bus.</span></span> <span data-ttu-id="45c91-253">Entre os possíveis motivos para a discrepância estão:</span><span class="sxs-lookup"><span data-stu-id="45c91-253">Possible reasons for the discrepancy include:</span></span>

- <span data-ttu-id="45c91-254">Não há valores ideais para vários parâmetros de cliente, como o limite do pool de conexões, o grau de paralelização, a contagem de pré-busca e o tamanho do lote.</span><span class="sxs-lookup"><span data-stu-id="45c91-254">Not having optimal values for various client parameters, such as the connection pool limit, the degree of parallelization, the prefetch count, and the batch size.</span></span>

- <span data-ttu-id="45c91-255">Gargalos de E/S de rede.</span><span class="sxs-lookup"><span data-stu-id="45c91-255">Network I/O bottlenecks.</span></span>

- <span data-ttu-id="45c91-256">Uso do modo [PeekLock](/rest/api/servicebus/peek-lock-message-non-destructive-read) em vez de [ReceiveAndDelete](/rest/api/servicebus/receive-and-delete-message-destructive-read), que era necessário para garantir a entrega de mensagens pelo menos uma vez.</span><span class="sxs-lookup"><span data-stu-id="45c91-256">Use of [PeekLock](/rest/api/servicebus/peek-lock-message-non-destructive-read) mode rather than [ReceiveAndDelete](/rest/api/servicebus/receive-and-delete-message-destructive-read), which was needed to ensure at-least-once delivery of messages.</span></span>

<span data-ttu-id="45c91-257">Testes de desempenho adicionais poderiam ter descoberto a causa raiz e permitido que resolvêssemos esses problemas.</span><span class="sxs-lookup"><span data-stu-id="45c91-257">Further performance tests might have discovered the root cause and allowed us to resolve these issues.</span></span> <span data-ttu-id="45c91-258">No entanto, o IoTHub React atendeu à nossa meta de desempenho, portanto escolhemos essa opção.</span><span class="sxs-lookup"><span data-stu-id="45c91-258">However, IotHub React met our performance target, so we chose that option.</span></span> <span data-ttu-id="45c91-259">Sendo assim, o Barramento de Serviço é uma opção viável para esse cenário.</span><span class="sxs-lookup"><span data-stu-id="45c91-259">That said, Service Bus is a viable option for this scenario.</span></span>

## <a name="handling-failures"></a><span data-ttu-id="45c91-260">Tratamento de falhas</span><span class="sxs-lookup"><span data-stu-id="45c91-260">Handling failures</span></span>

<span data-ttu-id="45c91-261">Há três classes gerais de falha a serem consideradas.</span><span class="sxs-lookup"><span data-stu-id="45c91-261">There are three general classes of failure to consider.</span></span>

1. <span data-ttu-id="45c91-262">Um serviço downstream pode ter uma falha não transitória, que é qualquer falha que provavelmente não desapareça por si só.</span><span class="sxs-lookup"><span data-stu-id="45c91-262">A downstream service may have a non-transient failure, which is any failure that's unlikely to go away by itself.</span></span> <span data-ttu-id="45c91-263">As falhas não transitórias incluem condições de erro normais, como uma entrada inválida para um método.</span><span class="sxs-lookup"><span data-stu-id="45c91-263">Non-transient failures include normal error conditions, such as invalid input to a method.</span></span> <span data-ttu-id="45c91-264">Elas também incluem exceções sem tratamento no código do aplicativo ou uma falha de processo.</span><span class="sxs-lookup"><span data-stu-id="45c91-264">They also include unhandled exceptions in application code or a process crashing.</span></span> <span data-ttu-id="45c91-265">Se esse tipo de erro ocorrer, a transação comercial inteira deverá ser marcada como uma falha.</span><span class="sxs-lookup"><span data-stu-id="45c91-265">If this type of error occurs, the entire business transaction must be marked as a failure.</span></span> <span data-ttu-id="45c91-266">Será necessário desfazer as outras etapas na mesma transação que já foram concluídas com êxito.</span><span class="sxs-lookup"><span data-stu-id="45c91-266">It may be necessary to undo other steps in the same transaction that already succeeded.</span></span> <span data-ttu-id="45c91-267">(Veja Transações de compensação abaixo.)</span><span class="sxs-lookup"><span data-stu-id="45c91-267">(See Compensating Transactions, below.)</span></span>

2. <span data-ttu-id="45c91-268">Um serviço de downstream pode apresentar uma falha temporária, como tempo limite de rede atingido.</span><span class="sxs-lookup"><span data-stu-id="45c91-268">A downstream service may experience a transient failure such as a network timeout.</span></span> <span data-ttu-id="45c91-269">Esses erros normalmente podem ser resolvidos simplesmente ao tentar a chamada novamente.</span><span class="sxs-lookup"><span data-stu-id="45c91-269">These errors can often be resolved simply by retrying the call.</span></span> <span data-ttu-id="45c91-270">Se a operação ainda falhar após um determinado número de tentativas, ela será considerada uma falha não transitória.</span><span class="sxs-lookup"><span data-stu-id="45c91-270">If the operation still fails after a certain number of attempts, it's considered a non-transient failure.</span></span>

3. <span data-ttu-id="45c91-271">O serviço de Agendador em si pode falhar (por exemplo, por causa de uma falha no nó).</span><span class="sxs-lookup"><span data-stu-id="45c91-271">The Scheduler service itself might fault (for example, because a node crashes).</span></span> <span data-ttu-id="45c91-272">Nesse caso, o Kubernetes abrirá uma nova instância do serviço.</span><span class="sxs-lookup"><span data-stu-id="45c91-272">In that case, Kubernetes will bring up a new instance of the service.</span></span> <span data-ttu-id="45c91-273">No entanto, as transações ainda em andamento deverão ser retomadas.</span><span class="sxs-lookup"><span data-stu-id="45c91-273">However, any transactions that were already in progress must be resumed.</span></span>

## <a name="compensating-transactions"></a><span data-ttu-id="45c91-274">Transações de compensação</span><span class="sxs-lookup"><span data-stu-id="45c91-274">Compensating transactions</span></span>

<span data-ttu-id="45c91-275">Se ocorrer uma falha não transitória, a transação atual poderá estar em um estado de *falha parcial*, em que uma ou mais etapas já foram concluídas com êxito.</span><span class="sxs-lookup"><span data-stu-id="45c91-275">If a non-transient failure happens, the current transaction might be in a *partially failed* state, where one or more steps already completed successfully.</span></span> <span data-ttu-id="45c91-276">Por exemplo, se o serviço de drone já tiver agendado um drone, ele deverá ser cancelado.</span><span class="sxs-lookup"><span data-stu-id="45c91-276">For example, if the Drone service already scheduled a drone, the drone must be canceled.</span></span> <span data-ttu-id="45c91-277">Nesse caso, o aplicativo deverá desfazer as etapas concluídas com êxito usando uma [transação de compensação](../patterns/compensating-transaction.md).</span><span class="sxs-lookup"><span data-stu-id="45c91-277">In that case, the application needs to undo the steps that succeeded, by using a [Compensating Transaction](../patterns/compensating-transaction.md).</span></span> <span data-ttu-id="45c91-278">Em alguns casos, isso deve ser feito por um sistema externo ou até mesmo por um processo manual.</span><span class="sxs-lookup"><span data-stu-id="45c91-278">In some cases, this must be done by an external system or even by a manual process.</span></span>

<span data-ttu-id="45c91-279">Se a lógica das transações de compensação for complexa, considere a criação de um serviço separado responsável por esse processo.</span><span class="sxs-lookup"><span data-stu-id="45c91-279">If the logic for compensating transactions is complex, consider creating a separate service that is responsible for this process.</span></span> <span data-ttu-id="45c91-280">No aplicativo de entrega por drone, o serviço de Agendador coloca as operações com falha em uma fila dedicada.</span><span class="sxs-lookup"><span data-stu-id="45c91-280">In the Drone Delivery application, the Scheduler service puts failed operations onto a dedicated queue.</span></span> <span data-ttu-id="45c91-281">Um microsserviço separado, chamado Supervisor, lê dessa fila e chama uma API de cancelamento nos serviços que precisam ser compensados.</span><span class="sxs-lookup"><span data-stu-id="45c91-281">A separate microservice, called the Supervisor, reads from this queue and calls a cancellation API on the services that need to compensate.</span></span> <span data-ttu-id="45c91-282">Essa é uma variação do [Padrão de Supervisor de Agente do Agendador][scheduler-agent-supervisor].</span><span class="sxs-lookup"><span data-stu-id="45c91-282">This is a variation of the [Scheduler Agent Supervisor pattern][scheduler-agent-supervisor].</span></span> <span data-ttu-id="45c91-283">O serviço de Supervisor também pode executar outras ações, como notificar o usuário por e-mail ou por SMS ou enviar um alerta para um painel de operações.</span><span class="sxs-lookup"><span data-stu-id="45c91-283">The Supervisor service might take other actions as well, such as notify the user by text or email, or send an alert to an operations dashboard.</span></span>

![Diagrama mostrando o microsserviço de Supervisor](./images/supervisor.png)

## <a name="idempotent-vs-non-idempotent-operations"></a><span data-ttu-id="45c91-285">Operações idempotentes e não idempotentes</span><span class="sxs-lookup"><span data-stu-id="45c91-285">Idempotent vs non-idempotent operations</span></span>

<span data-ttu-id="45c91-286">Para evitar a perda das solicitações, o serviço de Agendador deve assegurar que todas as mensagens sejam processadas pelo menos uma vez.</span><span class="sxs-lookup"><span data-stu-id="45c91-286">To avoid losing any requests, the Scheduler service must guarantee that all messages are processed at least once.</span></span> <span data-ttu-id="45c91-287">Os Hubs de Eventos poderão assegurar a entrega pelo menos uma vez se o cliente realizar o ponto de verificação corretamente.</span><span class="sxs-lookup"><span data-stu-id="45c91-287">Event Hubs can guarantee at-least-once delivery if the client checkpoints correctly.</span></span>

<span data-ttu-id="45c91-288">Se o serviço de Agendador falhar, poderá ser no meio do processamento de uma ou mais solicitações de cliente.</span><span class="sxs-lookup"><span data-stu-id="45c91-288">If the Scheduler service crashes, it may be in the middle of processing one or more client requests.</span></span> <span data-ttu-id="45c91-289">Essas mensagens serão retiradas por outra instância do Agendador e reprocessadas.</span><span class="sxs-lookup"><span data-stu-id="45c91-289">Those messages will be picked up by another instance of the Scheduler and reprocessed.</span></span> <span data-ttu-id="45c91-290">O que acontece se uma solicitação é processada duas vezes?</span><span class="sxs-lookup"><span data-stu-id="45c91-290">What happens if a request is processed twice?</span></span> <span data-ttu-id="45c91-291">É importante evitar a duplicação de qualquer trabalho.</span><span class="sxs-lookup"><span data-stu-id="45c91-291">It's important to avoid duplicating any work.</span></span> <span data-ttu-id="45c91-292">Afinal, não desejamos que o sistema envie dois drones para o mesmo pacote.</span><span class="sxs-lookup"><span data-stu-id="45c91-292">After all, we don't want the system to send two drones for the same package.</span></span>

<span data-ttu-id="45c91-293">Uma abordagem é criar todas as operações para que sejam idempotentes.</span><span class="sxs-lookup"><span data-stu-id="45c91-293">One approach is to design all operations to be idempotent.</span></span> <span data-ttu-id="45c91-294">Uma operação será idempotente se puder ser chamada várias vezes sem produzir efeitos colaterais adicionais após a primeira chamada.</span><span class="sxs-lookup"><span data-stu-id="45c91-294">An operation is idempotent if it can be called multiple times without producing additional side-effects after the first call.</span></span> <span data-ttu-id="45c91-295">Em outras palavras, um cliente poderá invocar a operação uma, duas ou muitas vezes e o resultado será o mesmo.</span><span class="sxs-lookup"><span data-stu-id="45c91-295">In other words, a client can invoke the operation once, twice, or many times, and the result will be the same.</span></span> <span data-ttu-id="45c91-296">O serviço basicamente deve ignorar chamadas duplicadas.</span><span class="sxs-lookup"><span data-stu-id="45c91-296">Essentially, the service should ignore duplicate calls.</span></span> <span data-ttu-id="45c91-297">Para um método com efeitos colaterais ser idempotentes, o serviço deverá ter a capacidade de detectar chamadas duplicadas.</span><span class="sxs-lookup"><span data-stu-id="45c91-297">For a method with side effects to be idempotent, the service must be able to detect duplicate calls.</span></span> <span data-ttu-id="45c91-298">Por exemplo, você pode solicitar que o responsável pela chamada atribua a ID, em vez de o serviço gerar uma nova ID.</span><span class="sxs-lookup"><span data-stu-id="45c91-298">For example, you can have the caller assign the ID, rather than having the service generate a new ID.</span></span> <span data-ttu-id="45c91-299">Com isso, o serviço pode verificar se há IDs duplicadas.</span><span class="sxs-lookup"><span data-stu-id="45c91-299">The service can then check for duplicate IDs.</span></span>

> [!NOTE]
> <span data-ttu-id="45c91-300">A especificação do HTTP declara que os métodos GET, PUT e DELETE devem ser idempotentes.</span><span class="sxs-lookup"><span data-stu-id="45c91-300">The HTTP specification states that GET, PUT, and DELETE methods must be idempotent.</span></span> <span data-ttu-id="45c91-301">Não há garantia que os métodos POST sejam idempotentes.</span><span class="sxs-lookup"><span data-stu-id="45c91-301">POST methods are not guaranteed to be idempotent.</span></span> <span data-ttu-id="45c91-302">Se um método POST criar um novo recurso, normalmente não haverá nenhuma garantia de que a operação será idempotente.</span><span class="sxs-lookup"><span data-stu-id="45c91-302">If a POST method creates a new resource, there is generally no guarantee that this operation is idempotent.</span></span>

<span data-ttu-id="45c91-303">Nem sempre é simples gravar um método idempotente.</span><span class="sxs-lookup"><span data-stu-id="45c91-303">It's not always straightforward to write idempotent method.</span></span> <span data-ttu-id="45c91-304">Outra opção é o Agendador acompanhar o andamento de todas as transações de um repositório durável.</span><span class="sxs-lookup"><span data-stu-id="45c91-304">Another option is for the Scheduler to track the progress of every transaction in a durable store.</span></span> <span data-ttu-id="45c91-305">Sempre que uma mensagem fosse processada, ele consultaria o estado no repositório durável.</span><span class="sxs-lookup"><span data-stu-id="45c91-305">Whenever it processes a message, it would look up the state in the durable store.</span></span> <span data-ttu-id="45c91-306">Depois de cada etapa, ele gravaria o resultado no repositório.</span><span class="sxs-lookup"><span data-stu-id="45c91-306">After each step, it would write the result to the store.</span></span> <span data-ttu-id="45c91-307">Pode haver implicações de desempenho nessa abordagem.</span><span class="sxs-lookup"><span data-stu-id="45c91-307">There may be performance implications to this approach.</span></span>

## <a name="example-idempotent-operations"></a><span data-ttu-id="45c91-308">Exemplo: operações idempotentes</span><span class="sxs-lookup"><span data-stu-id="45c91-308">Example: Idempotent operations</span></span>

<span data-ttu-id="45c91-309">A especificação do HTTP declara que os métodos PUT devem ser idempotentes.</span><span class="sxs-lookup"><span data-stu-id="45c91-309">The HTTP specification states that PUT methods must be idempotent.</span></span> <span data-ttu-id="45c91-310">A especificação define idempotente da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="45c91-310">The specification defines idempotent this way:</span></span>

> <span data-ttu-id="45c91-311">um método de solicitação será considerado "idempotente" se o efeito desejado no servidor de várias solicitações idênticas com esse método for o mesmo efeito de uma única solicitação como essa.</span><span class="sxs-lookup"><span data-stu-id="45c91-311">A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request.</span></span> <span data-ttu-id="45c91-312">([RFC 7231](https://tools.ietf.org/html/rfc7231#section-4))</span><span class="sxs-lookup"><span data-stu-id="45c91-312">([RFC 7231](https://tools.ietf.org/html/rfc7231#section-4))</span></span>

<span data-ttu-id="45c91-313">É importante entender a diferença entre a semântica de PUT e de POST ao criar uma nova entidade.</span><span class="sxs-lookup"><span data-stu-id="45c91-313">It's important to understand the difference between PUT and POST semantics when creating a new entity.</span></span> <span data-ttu-id="45c91-314">Em ambos os casos, o cliente envia uma representação de uma entidade no corpo da solicitação.</span><span class="sxs-lookup"><span data-stu-id="45c91-314">In both cases, the client sends a representation of an entity in the request body.</span></span> <span data-ttu-id="45c91-315">No entanto, o significado do URI é diferente.</span><span class="sxs-lookup"><span data-stu-id="45c91-315">But the meaning of the URI is different.</span></span>

- <span data-ttu-id="45c91-316">Para um método POST, o URI representa um recurso pai da nova entidade, como uma coleção.</span><span class="sxs-lookup"><span data-stu-id="45c91-316">For a POST method, the URI represents a parent resource of the new entity, such as a collection.</span></span> <span data-ttu-id="45c91-317">Por exemplo, para criar uma nova entrega, o URI pode ser `/api/deliveries`.</span><span class="sxs-lookup"><span data-stu-id="45c91-317">For example, to create a new delivery, the URI might be `/api/deliveries`.</span></span> <span data-ttu-id="45c91-318">O servidor cria a entidade e atribui a ela um novo URI, como `/api/deliveries/39660`.</span><span class="sxs-lookup"><span data-stu-id="45c91-318">The server creates the entity and assigns it a new URI, such as `/api/deliveries/39660`.</span></span> <span data-ttu-id="45c91-319">Esse URI é retornado no cabeçalho de Localização da resposta.</span><span class="sxs-lookup"><span data-stu-id="45c91-319">This URI is returned in the Location header of the response.</span></span> <span data-ttu-id="45c91-320">Cada vez que o cliente enviar uma solicitação, o servidor criará uma nova entidade com um novo URI.</span><span class="sxs-lookup"><span data-stu-id="45c91-320">Each time the client sends a request, the server will create a new entity with a new URI.</span></span>

- <span data-ttu-id="45c91-321">Para um método PUT, o URI identifica a entidade.</span><span class="sxs-lookup"><span data-stu-id="45c91-321">For a PUT method, the URI identifies the entity.</span></span> <span data-ttu-id="45c91-322">Se já existir uma entidade com esse URI, o servidor substituirá a entidade existente pela versão na solicitação.</span><span class="sxs-lookup"><span data-stu-id="45c91-322">If there already exists an entity with that URI, the server replaces the existing entity with the version in the request.</span></span> <span data-ttu-id="45c91-323">Se nenhuma entidade existir com esse URI, o servidor criará uma.</span><span class="sxs-lookup"><span data-stu-id="45c91-323">If no entity exists with that URI, the server creates one.</span></span> <span data-ttu-id="45c91-324">Por exemplo, suponha que o cliente envie uma solicitação PUT para `api/deliveries/39660`.</span><span class="sxs-lookup"><span data-stu-id="45c91-324">For example, suppose the client sends a PUT request to `api/deliveries/39660`.</span></span> <span data-ttu-id="45c91-325">Pressupondo que não exista nenhuma entrega com esse URI, o servidor criará uma nova.</span><span class="sxs-lookup"><span data-stu-id="45c91-325">Assuming there is no delivery with that URI, the server creates a new one.</span></span> <span data-ttu-id="45c91-326">Agora se o cliente enviar a mesma solicitação novamente, o servidor substituirá a entidade existente.</span><span class="sxs-lookup"><span data-stu-id="45c91-326">Now if the client sends the same request again, the server will replace the existing entity.</span></span>

<span data-ttu-id="45c91-327">Veja abaixo a implementação do serviço de Entrega do método PUT.</span><span class="sxs-lookup"><span data-stu-id="45c91-327">Here is the Delivery service's implementation of the PUT method.</span></span>

```csharp
[HttpPut("{id}")]
[ProducesResponseType(typeof(Delivery), 201)]
[ProducesResponseType(typeof(void), 204)]
public async Task<IActionResult> Put([FromBody]Delivery delivery, string id)
{
    logger.LogInformation("In Put action with delivery {Id}: {@DeliveryInfo}", id, delivery.ToLogInfo());
    try
    {
        var internalDelivery = delivery.ToInternal();

        // Create the new delivery entity.
        await deliveryRepository.CreateAsync(internalDelivery);

        // Create a delivery status event.
        var deliveryStatusEvent = new DeliveryStatusEvent { DeliveryId = delivery.Id, Stage = DeliveryEventType.Created };
        await deliveryStatusEventRepository.AddAsync(deliveryStatusEvent);

        // Return HTTP 201 (Created)
        return CreatedAtRoute("GetDelivery", new { id= delivery.Id }, delivery);
    }
    catch (DuplicateResourceException)
    {
        // This method is mainly used to create deliveries. If the delivery already exists then update it.
        logger.LogInformation("Updating resource with delivery id: {DeliveryId}", id);

        var internalDelivery = delivery.ToInternal();
        await deliveryRepository.UpdateAsync(id, internalDelivery);

        // Return HTTP 204 (No Content)
        return NoContent();
    }
}
```

<span data-ttu-id="45c91-328">Espera-se que a maioria das solicitações criará uma nova entidade, portanto o método chamará de maneira otimista `CreateAsync` no objeto de repositório e, em seguida, tratará as exceções de recurso duplicado atualizando o recurso.</span><span class="sxs-lookup"><span data-stu-id="45c91-328">It's expected that most requests will create a new entity, so the method optimistically calls `CreateAsync` on the repository object, and then handles any duplicate-resource exceptions by updating the resource instead.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="45c91-329">Gateways de API</span><span class="sxs-lookup"><span data-stu-id="45c91-329">API gateways</span></span>](./gateway.md)

<!-- links -->

[scheduler-agent-supervisor]: ../patterns/scheduler-agent-supervisor.md