---
title: Arquitetura de aplicativos do Azure para resiliência e disponibilidade
description: Criar resiliência e disponibilidade em um aplicativo do Azure
author: MikeWasson
ms.date: 04/10/2019
ms.topic: article
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.openlocfilehash: ee4bb5b4a85e48fe0ff017297c31823c93a48f04
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59646482"
---
# <a name="architecting-azure-applications-for-resiliency-and-availability"></a>Arquitetura de aplicativos do Azure para resiliência e disponibilidade

Depois de desenvolver os requisitos para o seu aplicativo, a próxima etapa é criar a disponibilidade e resiliência para ele. Essas qualidades não podem ser adicionadas ao final &mdash; você deve criá-las na arquitetura.

## <a name="conduct-a-failure-mode-analysis"></a>Conduzir uma análise do modo de falha

*Análise do modo de falha* (FMA) compila resiliência em um sistema, identificando possíveis pontos de falha e definir como o aplicativo responde a essas falhas. A FMA deve ser parte das fases de arquitetura e design, portanto, a recuperação de falhas é interna no sistema desde o início. Os objetivos de uma FMA são:

- Determine quais tipos de falhas de um aplicativo pode enfrentar e como o aplicativo detecta essas falhas.
- Capturar os possíveis efeitos de cada tipo de falha e determinar como o aplicativo responde.
- Planejar para registro em log e monitoramento da falha e identificar estratégias de recuperação.

Aqui estão alguns exemplos de modos de falha e estratégias de detecção para um ponto de falha específico &mdash; uma chamada para um serviço web externo:

| Modo de falha           | Estratégia de detecção           |
|------------------------|------------------------------|
| O serviço está indisponível | HTTP 5xx                     |
| Limitação             | HTTP 429 (Número Excessivo de Solicitações) |
| Autenticação         | HTTP 401 (Não Autorizado)      |
| Resposta lenta          | Tempo limite da solicitação atingido            |

Para obter mais informações sobre o processo FMA, com as recomendações específicas para o Azure, consulte [análise do modo de falha](../resiliency/failure-mode-analysis.md).

## <a name="plan-for-redundancy"></a>Plano para redundância

Falhas variam no escopo do impacto. Algumas falhas de hardware, como um disco com falha, afetam um único computador host. Um comutador de rede com falha pode afetar um rack de servidores inteiro. Falhas menos comuns, como perda de energia, interrompem um datacenter inteiro. Raramente, toda a região fica indisponível.

A redundância é uma maneira de se tornar um aplicativo resiliente. O nível de redundância depende de seus requisitos de negócios &mdash; nem todos os aplicativos precisam de redundância entre regiões para se proteger contra uma interrupção regional. Em geral, há um equilíbrio entre mais redundância e confiabilidade em comparação com maior complexidade e os custos.

### <a name="review-azure-redundancy-features"></a>Analise os recursos de redundância do Azure

O Azure tem um número de recursos de redundância em todos os níveis de falha de uma máquina virtual (VM) individual em uma região inteira.

- **As VMs únicas** tem um [contrato de nível de serviço (SLA) do tempo de atividade](https://azure.microsoft.com/support/legal/sla/virtual-machines) fornecida pelo Azure. (A VM deve usar o armazenamento premium para todos os discos do sistema operacional e discos de dados). Embora você possa obter um SLA mais alto executando duas ou mais VMs, uma única VM pode ser suficientemente confiável para algumas cargas de trabalho. No entanto, para cargas de trabalho de produção, é recomendável usar duas ou mais máquinas virtuais para redundância.
- **Conjuntos de disponibilidade** proteger contra falhas de hardware localizadas, como um disco ou com falha do comutador de rede. As VMs no conjunto de disponibilidade são distribuídas entre até três *domínios de falha*. Um domínios de falha define um grupo de VMs que compartilham um comutador de rede e fonte de energia comuns. Se uma falha de hardware afeta um domínio de falha, o tráfego de rede é roteado para VMs em outros domínios de falha. Para obter mais informações sobre conjuntos de disponibilidade, consulte [gerenciar a disponibilidade das máquinas de virtuais do Windows no Azure](/azure/virtual-machines/windows/manage-availability).
- **As zonas de disponibilidade** são regiões fisicamente separadas dentro de uma região do Azure. Cada zona de disponibilidade tem uma rede, resfriamento e fonte de energia distintos. Implantação de VMs entre zonas de disponibilidade ajuda a proteger um aplicativo contra falhas de todo o datacenter. Nem todas as regiões oferecem suporte às Zonas de Disponibilidade. Para obter uma lista de regiões com suporte e serviços, confira [O que são Zonas de Disponibilidade no Azure?](/azure/availability-zones/az-overview).

    Se você planeja usar as zonas de disponibilidade em sua implantação, primeiro valide que a arquitetura do aplicativo e a base de suporte para essa configuração. Se você implantar o software comercial, consulte o fornecedor de software e testar adequadamente antes de implantar na produção. Um aplicativo deve manter o estado e evitar a perda de dados durante uma interrupção dentro da zona configurada. O aplicativo deve oferecer suporte à execução em uma infraestrutura elástica e distribuída com nenhum componente de infraestrutura embutido em código.
- **O Azure Site Recovery** precisa de máquinas virtuais do Azure para outra região do Azure para continuidade de negócios (BC) e recuperação de desastres (DR) é replicada. Você pode realizar análises de recuperação de desastres periódicos para verificar se você atende as necessidades de conformidade. A VM é replicada com as configurações especificadas para a região selecionada para que possa recuperar seus aplicativos em caso de paralisações na região de origem. Para obter mais informações, consulte [configurar a recuperação de desastre para uma região secundária do Azure para uma VM do Azure](/azure/site-recovery/azure-to-azure-quickstart/).

    Durante o teste, verifique se o *objetivo de tempo de recuperação* (RTO) e *objetivo de ponto de recuperação* (RPO) atender às suas necessidades. O RTO é o tempo máximo que um aplicativo não está disponível após um incidente e o RPO é a duração máxima de perda de dados durante um desastre.
- **Regiões emparelhadas** são criados usando o Gerenciador de tráfego do Azure para distribuir o tráfego da Internet para diferentes regiões, proteger um aplicativo contra uma interrupção regional. Cada região do Azure é emparelhada com outra. Juntas, essas regiões formam um [ *par regional*](/azure/best-practices-availability-paired-regions). Para atender aos requisitos de residência de dados para fins de jurisdição de imposição fiscal e legal, pares regionais estão localizados na mesma região geográfica (com exceção do Sul do Brasil).

    Para melhorar a resiliência do aplicativo, o Azure serializa as atualizações de plataforma (manutenção planejada) entre cada par de região, para que apenas uma região emparelhada é atualizado a cada vez.
- Quando você criar um aplicativo multiregion, leve em consideração que a latência de rede entre regiões é maior do que em uma região. Por exemplo, se você replicar um banco de dados para habilitar o failover, use a replicação síncrona de dados dentro de uma região, mas a replicação de dados assíncrona entre regiões.

A tabela a seguir compara os fatores de redundância entre várias estratégias de resiliência:

| &nbsp; | Conjunto de disponibilidade | Zona de disponibilidade | Azure Site Recovery/Região emparelhada |
|--------|------------------|-------------------|-----------------------------------|
| Escopo da falha | Rack                  | Datacenter               | Região                               |
| Roteamento de solicitação  | Azure Load Balancer   | Load Balancer entre zonas | Gerenciador de Tráfego do Azure                |
| Latência da rede  | Muito baixa              | Baixo                      | Média a alta                          |
| Rede virtual  | Rede Virtual do Azure | Rede Virtual do Azure          | Emparelhamento de rede Virtual entre regiões |

### <a name="complete-azure-redundancy-tasks"></a>Tarefas de redundância do Azure completa

Use as seguintes tarefas para atender aos requisitos de redundância:

- **Implante várias instâncias de serviços.** Se seu aplicativo depender de uma única instância de um serviço, ele criará um único ponto de falha. O provisionamento de várias instâncias melhora a resiliência e a escalabilidade. Para o [Serviço de Aplicativo do Azure](/azure/app-service/app-service-value-prop-what-is/), selecione um [Plano do Serviço de Aplicativo](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/) que ofereça várias instâncias. Para [máquinas virtuais do Azure](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json), certifique-se de que a arquitetura tem mais de uma VM e se cada VM está incluída em uma [conjunto de disponibilidade](/azure/virtual-machines/virtual-machines-windows-manage-availability/).

- **Replique VMs usando o Azure Site Recovery.** Quando você replicar VMs do Azure usando [recuperação de Site](/azure/site-recovery/), todos os discos VM são replicados continuamente para a região de destino assincronamente. Os pontos de recuperação são criados cada poucos minutos, oferecendo um RPO na ordem de minutos.

- **Considere implantar o aplicativo entre várias regiões.** Se seu aplicativo for implantado em uma única região e a região ficar indisponível, o aplicativo também estará disponível. Isso pode ser inaceitável segundo os termos do SLA do aplicativo. Nesse caso, considere implantar o aplicativo e os respectivos serviços entre várias regiões. Uma implantação multiregion pode usar um *ativo-ativo* ou *ativo-passivo* configuração. Uma configuração ativo-ativo distribui solicitações entre várias regiões ativas. Uma configuração ativa-passiva mantém instâncias passivos na região secundária, mas não envia o tráfego lá, a menos que a região principal falhar. Para implantações multiregion, é recomendável implantar em regiões emparelhadas, descritas acima. Para saber mais, confira [Continuidade dos negócios e recuperação de desastres (BCDR): Regiões Combinadas do Azure](/azure/best-practices-availability-paired-regions).

- **Use o Gerenciador de Tráfego do Azure para rotear o tráfego do seu aplicativo para regiões diferentes.** [O Gerenciador de tráfego do Azure](/azure/traffic-manager/traffic-manager-overview/) executa o balanceamento de carga no nível do DNS e encaminha o tráfego para regiões diferentes com base em de [roteamento de tráfego](/azure/traffic-manager/traffic-manager-routing-methods/) método e a integridade dos pontos de extremidade do seu aplicativo. Sem o Gerenciador de tráfego, você está limitado a uma única região para sua implantação, que restringe a escala, aumenta a latência para alguns usuários e faz com que o tempo de inatividade do aplicativo, no caso de uma interrupção do serviço de toda a região.

- **Configure o Gateway de aplicativo do Azure para usar várias instâncias.** Dependendo dos requisitos do seu aplicativo, um [Gateway de Aplicativo do Azure](/azure/application-gateway/application-gateway-introduction/) pode ser mais conveniente para distribuir solicitações para os serviços do aplicativo. No entanto, instâncias únicas do serviço de Gateway de aplicativo não garantidas por um SLA, portanto, é possível que seu aplicativo poderá falhar se a instância do Gateway de aplicativo falhar. Provisione mais de uma instância de médias ou maior para garantir a disponibilidade do serviço sob os termos do [SLA de Gateway de aplicativo](https://azure.microsoft.com/support/legal/sla/application-gateway/).

## <a name="design-for-scalability"></a>Design para escalabilidade

*Escalabilidade* é a capacidade de um sistema de lidar com aumentos de carga e é um dos [pilares da qualidade do software](../guide/pillars.md). Tarefas de escalabilidade durante a fase de arquitetura incluem:

- **Cargas de trabalho de partição.** Crie partes do processo para serem decompostas e distintas. Minimize o tamanho de cada parte. Isso permite que os componentes sejam distribuídos de forma a maximiza o uso de cada unidade de computação. Isso também facilita o dimensionamento do aplicativo ao adicionar instâncias de recursos específicos. Para domínios complexos, considere a possibilidade de adotar uma [arquitetura de microsserviços](../guide/architecture-styles/microservices.md).
- **Projete o dimensionamento.** Dimensionamento permite que aplicativos reajam à carga variável, aumentando e diminuindo o número de instâncias de funções, filas e outros serviços. No entanto, o aplicativo deve ser projetado com isso em mente. Por exemplo, o aplicativo e os serviços que ele usa devem ser sem monitoração de estado para permitir que as solicitações sejam roteadas para qualquer instância. Serviços sem monitoração de estado também significa que a adição ou remoção de uma instância não afeta negativamente os usuários atuais.
- **Planeje o crescimento com unidades de escala.** Para cada recurso, saber os limites de dimensionamento superiores e use a fragmentação ou Decomposição para ir além desses limites. Crie o aplicativo para que ele seja facilmente dimensionado com a adição de uma ou mais unidades de escala. Determine as unidades de escala para o sistema em termos de conjuntos bem definidos de recursos. Isso torna aplicando operações de escala horizontal mais fácil e menos propensa a um impacto negativo causado por falta de recursos em alguma parte do sistema geral. Por exemplo, adicionando *X* número de VMs de front-end pode exigir *Y* número de filas adicionais e *Z* número de contas de armazenamento para lidar com a carga de trabalho adicional. Portanto, uma unidade de escala poderia consistir *X* instâncias de VM *Y* filas, e *Z* contas de armazenamento.
- **Evite a afinidade do cliente.** Sempre que possível, certifique-se de que o aplicativo não requer afinidade. As solicitações, em seguida, podem ser roteadas para qualquer instância e o número de instâncias é irrelevante. Isso também evita a sobrecarga de armazenamento, de recuperação e de manutenção de informações de estado para cada usuário.
- **Tirar proveito dos recursos de dimensionamento automático de plataforma.** Usar recursos de dimensionamento automático internos quando possível, em vez de mecanismos de terceiros ou personalizados. Regras de dimensionamento de uso agendado, sempre que possível, para garantir que recursos estão disponíveis sem um atraso de inicialização, mas adicionar o dimensionamento automático reativo às regras, quando apropriado, para lidar com alterações inesperadas na demanda. Para obter mais informações, consulte [diretrizes de dimensionamento automático](../best-practices/auto-scaling.md).  

  Se seu aplicativo não estiver configurado para expandir automaticamente conforme a carga aumenta, é possível que os serviços do aplicativo falhará se ficarem saturados com solicitações de usuário. Para obter mais informações, consulte os seguintes artigos:

  - Geral: [Lista de verificação de escalabilidade](../checklist/scalability.md)
  - Serviço de Aplicativo do Azure: [Escalonar a contagem de instâncias manualmente ou automaticamente](/azure/monitoring-and-diagnostics/insights-how-to-scale/)
  - Serviços de Nuvem: [Como fazer o dimensionamento automático de um serviço de nuvem](/azure/cloud-services/cloud-services-how-to-scale/)
  - Máquinas virtuais: [Conjuntos de dimensionamento de dimensionamento automático e máquina virtual](/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-autoscale-overview/)

- **Descarregue tarefas intensivas de CPU/es como tarefas em segundo plano.** Se uma solicitação para um serviço deve levar muito tempo para ser executado ou pode absorva recursos consideráveis, descarregar o processamento de uma tarefa separada. Use trabalhos em segundo plano para executar essas tarefas. Essa estratégia permite que o serviço para continuar a receber outras solicitações e permaneça responsivo. Para saber mais, consulte [Diretrizes de trabalhos em segundo plano](../best-practices/background-jobs.md).
- **Distribua a carga de trabalho para tarefas em segundo plano.** Se houver muitas tarefas em segundo plano ou se as tarefas exigem tempo ou recursos consideráveis, distribua o trabalho entre várias unidades de computação. Para ver uma solução possível, confira [Padrão de clientes concorrentes](../patterns/competing-consumers.md).
- **Considere mudar para um *nada compartilhado* arquitetura.** Essa arquitetura usa nós independentes e autossuficientes com nenhum ponto único de contenção (como serviços compartilhados ou armazenamento). Em tese, esse sistema pode ser dimensionado quase indefinidamente. Embora uma abordagem completa de nada compartilhado geralmente não é prática, ele pode fornecer oportunidades de projetar uma escalabilidade melhor. Bons exemplos de uma arquitetura de nada compartilhado na direção incluem o particionamento de dados e evitar o uso de afinidade de cliente e o estado de sessão do lado do servidor.
- **Projete os requisitos de armazenamento do seu aplicativo para ficarem dentro das metas de desempenho e escalabilidade do armazenamento do Azure.** O armazenamento do Azure foi projetado para funcionar dentro dos destinos de escalabilidade e desempenho predefinidos, portanto, projete seu aplicativo para usar o armazenamento dentro dessas metas. Se você exceder essas metas, seu aplicativo sofrerá uma limitação de armazenamento. Para evitar a limitação, provisione contas de armazenamento adicionais. Se você atingir o limite de conta de armazenamento, provisionar assinaturas adicionais do Azure e, em seguida, há contas de armazenamento adicionais. Para saber mais, confira [Metas de desempenho e escalabilidade do Armazenamento do Azure](/azure/storage/storage-scalability-targets/).
- **Selecione o tamanho de VM certo para o aplicativo.** Medir a CPU, memória, disco e e/s de suas VMs em produção real e verifique se o tamanho da VM que você selecionou é suficiente. Se não é, seu aplicativo pode apresentar problemas de capacidade, tais como VMs se aproximarem de seus limites. Tamanhos de VM são descritos em detalhes em [Tamanhos de máquinas virtuais no Azure](/azure/virtual-machines/virtual-machines-windows-sizes/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).

## <a name="determine-subscription-and-service-requirements"></a>Determinar os requisitos de serviço e assinatura

Escolha a assinatura correta e recursos de serviço para seu aplicativo, apresentando estas tarefas:

- **Avaliar os requisitos em relação aos [assinatura do Azure e limites de serviço](/azure/azure-subscription-service-limits/).** *As assinaturas do Azure* têm limites em determinados tipos de recurso, como o número de grupos de recursos, núcleos e contas de armazenamento. Se seus requisitos de aplicativo excedem os limites de assinatura do Azure, crie outra assinatura do Azure e provisione recursos suficientes nela. Os serviços do Azure individuais têm limites de consumo &mdash; por exemplo, limites para armazenamento, taxa de transferência, número de conexões, solicitações por segundo e outras métricas. O aplicativo falhará se ele tentar usar recursos além desses limites, resultando em serviço limitação e possível tempo de inatividade para os usuários afetados. Dependendo do serviço específico e seus requisitos de aplicativo, você geralmente pode evitar esses limites, escalar verticalmente (por exemplo, escolher outro tipo de preço) ou a expansão (como adicionar novas instâncias).
- **Determine quantas contas de armazenamento que você precisa.** Azure permite que um número específico de contas de armazenamento por assinatura. Para saber mais, confira [Assinatura e limites de serviço, cotas e restrições do Azure](/azure/azure-subscription-service-limits/#storage-limits).
- **Selecione a camada de serviço certa para o Banco de Dados SQL do Azure.** Se seu aplicativo usa o banco de dados SQL, selecione a camada de serviço apropriado. Se a camada não pode lidar com requisitos de DTU (unidade) de transação de banco de dados do seu aplicativo, o uso de dados será limitado. Para obter mais informações sobre como selecionar o plano de serviço correto, veja [Opções e desempenho de Banco de Dados SQL: Entenda o que está disponível em cada camada de serviço](/azure/sql-database/sql-database-service-tiers/).
- **Provisionar unidades de solicitação (RUs) suficientes no Azure Cosmos DB**. Com o Azure Cosmos DB, você paga pela taxa de transferência provisionada e pelo armazenamento que consome por hora. O custo de todas as operações de banco de dados é normalizado como RUs, que abstrai os recursos do sistema, como CPU, memória e IOPS. Para obter mais informações, consulte [Unidades de Solicitação no Azure Cosmos DB](/azure/cosmos-db/request-units).

## <a name="load-balance-as-needed"></a>Conforme a necessidade de balanceamento de carga

Balanceamento de carga adequado, permite que você para atender aos requisitos de disponibilidade e para minimizar os custos associados à disponibilidade.

- **Use o balanceamento de carga para distribuir solicitações.** Balanceamento de carga distribui as solicitações do seu aplicativo para instâncias de serviço íntegras Removendo instâncias não íntegras da rotação. Se o serviço usar o serviço de aplicativo do Azure ou serviços de nuvem do Azure, ele já está com balanceamento de carga para você. No entanto, se seu aplicativo usa VMs do Azure, você precisará provisionar um balanceador de carga. Para obter mais informações, consulte [o que é o balanceador de carga do Azure?](/azure/load-balancer/load-balancer-overview/)

  Use o Azure Load Balancer para:

  - O balanceamento de carga o tráfego da Internet em suas VMs. Essa configuração é conhecida como uma [ *balanceador de carga público*](/azure/load-balancer/load-balancer-overview#publicloadbalancer).
  - Balancear a carga do tráfego entre VMs dentro de uma rede virtual. Também é possível acessar o front-end de um Load Balancer de uma rede local em um cenário híbrido. Ambos os cenários usam uma configuração que é conhecida como um [ *balanceador de carga interno*](/azure/load-balancer/load-balancer-overview#internalloadbalancer).
  - Tráfego de encaminhamento de porta para uma porta discriminada em VMs específicas com regras NAT (conversão) de endereço de rede de entrada.
  - Forneça [conectividade de saída](/azure/load-balancer/load-balancer-outbound-connections) para VMs dentro de sua rede virtual usando um Load Balancer público.

- **Distribua cargas pelos regiões com um Gerenciador de tráfego, como o Gerenciador de tráfego do Azure.** Balancear a carga de tráfego entre regiões requer uma solução de gerenciamento de tráfego e o Azure fornece [Gerenciador de tráfego](https://azure.microsoft.com/services/traffic-manager/). Você também pode tirar proveito dos serviços de terceiros que oferecem recursos semelhantes de gerenciamento de tráfego.

## <a name="implement-resiliency-strategies"></a>Implementar estratégias de resiliência

Esta seção descreve algumas estratégias comuns de resiliência. A maioria dessas estratégias não está limitada a uma tecnologia específica. As descrições resumem a ideia geral por trás de cada técnica e incluem links para leitura adicional.

- **Implementar padrões de resiliência** para operações remotas, quando apropriado. Se seu aplicativo depende da comunicação entre serviços remotos, siga [padrões de design](../patterns/category/resiliency.md) para lidar com falhas transitórias.

- **Repetição de falhas transitórias.** Isso pode ser provocado por perda momentânea de conectividade de rede, uma conexão de banco de dados descartados ou um tempo limite quando um serviço está ocupado. Muitas vezes, uma falha temporária pode ser resolvida repetindo-se a solicitação.

  - Para muitos serviços do Azure, o kit de desenvolvimento de software (SDK) cliente implementa novas tentativas automáticas de forma transparente para o chamador. Ver [diretrizes de repetição para serviços específicos](../best-practices/retry-service-specific.md).
  - Ou implementar o [padrão de repetição](../patterns/retry.md) para ajudar a lidar com falhas previstas e temporárias transparente quando ele tenta se conectar a um serviço ou recurso de rede do aplicativo.

- **Usar um disjuntor** para lidar com falhas que possam consumir uma quantidade variável de tempo para serem corrigidos. O [padrão de disjuntor](../patterns/circuit-breaker.md) pode impedir que um aplicativo tentar repetidamente uma operação que provavelmente falhará. O disjuntor encapsula as chamadas em um serviço e controla o número de falhas recentes. Se a contagem de falhas exceder um limite, o disjuntor será iniciado retornando um código de erro sem chamar o serviço. Isso fornece o tempo de serviço de recuperação e ajuda a evitar falhas em cascata.
- **Isole recursos críticos.** Falhas em um subsistema podem, às vezes, em cascata, resultando em falhas em outras partes do aplicativo. Isso pode acontecer se uma falha impede que recursos como threads ou soquetes seja liberado, levando a exaustão de recursos. Para evitar isso, você pode particionar um sistema em grupos isolados, de modo que uma falha em uma partição não coloca todo o sistema inoperante.

    Aqui estão alguns exemplos dessa técnica, que é chamado, às vezes, o [padrão de Bulkhead](../patterns/bulkhead.md):

  - Particionar um banco de dados (por exemplo, por Locatário) e atribua um pool separado de instâncias do servidor web para cada partição.
  - Usar pools de threads separados, para isolar as chamadas para diferentes serviços. Isso ajuda a evitar falhas em cascata, se houver falha em um dos serviços. Por exemplo, consulte o Netflix [biblioteca Hystrix](https://medium.com/netflix-techblog/introducing-hystrix-for-resiliency-engineering-13531c1ab362).
  - Use [contêineres](https://en.wikipedia.org/wiki/Operating-system-level_virtualization) para limitar os recursos disponíveis para um determinado subsistema.

      ![Diagrama do padrão de Bulkhead](_images/bulkhead.png)

- **Aplique [ *transações de compensação*](../patterns/compensating-transaction.md)**. Uma transação de compensação é uma operação que desfaz os efeitos de outra transação concluída. Em um sistema distribuído, pode ser difícil de obter consistência transacional sólida. Transações de compensação ajudam a obter consistência usando uma série de transações individuais menores, que podem ser desfeitas em cada etapa. Por exemplo, para fazer uma viagem, um cliente pode precisar reservar um voo, acomodações de hotel e um carro. Se uma destas etapas falhar, toda a operação falhará. Em vez de tentar usar uma única transação distribuída em toda a operação, você pode definir uma transação de compensação para cada etapa.
- **Implementar operações assíncronas, sempre que possível.** Operações síncronas podem monopolizar os recursos e bloquear outras operações enquanto o chamador aguarda a conclusão do processo. Crie cada parte do seu aplicativo para permitir operações assíncronas, sempre que possível. Para obter mais informações sobre como implementar a programação assíncrona em C\#, consulte [programação assíncrona](/dotnet/articles/csharp/async).

## <a name="ensure-that-availability-meets-slas"></a>Certifique-se de que a disponibilidade atenda aos SLAs

*Disponibilidade* é a proporção de tempo que um sistema está funcionando, e é um dos [pilares da qualidade do software](../guide/pillars.md). Use as tarefas nesta seção para examinar a arquitetura de aplicativo de um ponto de vista de disponibilidade para certificar-se de que sua disponibilidade atende aos seus SLAs.

- **Evite quaisquer pontos únicos de falha.**  Todos os componentes, serviços, recursos e instâncias de computação devem ser implantados como várias instâncias para impedir que um ponto único de falha afete a disponibilidade. Mecanismos de autenticação também podem ser um ponto único de falha. O design do aplicativo para ser configurável para usar várias instâncias e para detectar falhas e redirecionar as solicitações para instâncias sem falha, se a plataforma não faz isso automaticamente.
- **Decompor as cargas de trabalho por objetivo de nível de serviço.**  Se um serviço for composto por cargas de trabalho críticas e outras menos críticas, gerencie-as de maneira diferente e especifique os recursos de serviço e o número de instâncias para atender aos requisitos de disponibilidade dessas cargas de trabalho.
- **Minimize e entenda as dependências de serviço.** Minimize o número de serviços diferentes usados, sempre que possível. Certifique-se de que você compreenda todas as dependências de recurso e o serviço existem no sistema. Em particular, compreenda o impacto geral de falha ou redução do desempenho em cada dependência.
- **Crie tarefas e as mensagens sejam *idempotente*, sempre que possível.** Uma operação é idempotente caso possa ser repetida várias vezes e produzir o mesmo resultado. Isso pode garantir que solicitações duplicadas não causem problemas. Consumidores de mensagens e as operações que eles realizam devem ser idempotentes de modo que repetir uma operação executada anteriormente não torne os resultados inválidos. Isso pode significar detecção duplicada de mensagens ou garantir a consistência usando uma abordagem otimista para tratar dos conflitos.
- **Configure o tempo limite de solicitações.** Serviços e recursos podem tornar-se indisponíveis, fazendo com que determinadas solicitações falhem. Certifique-se de que os tempos limite aplicados são apropriados para cada serviço ou recurso e para o cliente que está acessando-os. Em alguns casos, você pode permitir um tempo limite maior para uma instância específica de um cliente, dependendo do contexto e de outras ações que o cliente esteja realizando. Tempos limite curto pode causar operações excessivas de repetição para serviços e recursos que têm uma latência considerável. Tempos limite longo pode causar o bloqueio, se um grande número de solicitações é enfileirado, aguardando um serviço ou recurso para responder.
- **Use um agente de mensagem que implemente alta disponibilidade para transações críticas.** Muitos aplicativos de nuvem usam a mensagem para disparar tarefas assíncronas. Para garantir a entrega de mensagens, o sistema de mensagens deve oferecer alta disponibilidade. [Mensagens de barramento de serviço do Azure](/azure/service-bus-messaging) implementa *pelo menos uma vez* semântica, o que significa que uma mensagem é garantida para ser entregue pelo menos uma vez. Podem ser entregue mensagens duplicadas em determinadas circunstâncias. Se o processamento de mensagens for idempotente (consulte o item anterior), a repetição na entrega não deverá ser um problema.
- **Limite os usuários de alto volume.** Às vezes, um pequeno número de usuários cria carga excessiva. Isso pode ter um impacto em outros usuários e pode reduzir a disponibilidade geral do seu aplicativo. Quando um único cliente faz um número excessivo de solicitações, o aplicativo pode limitá-lo por um determinado período. Durante o período de limitação, o aplicativo recusa algumas ou todas as solicitações desse cliente. O limite de limitação geralmente depende da camada de serviço do cliente. Para obter mais informações, consulte [padrão de limitação](../patterns/throttling.md).

    A limitação não significa que o cliente necessariamente estava agindo maliciosamente &mdash; apenas que ele excedeu sua cota de serviço. Pode acontecer que o consumidor exceda sua cota frequentemente, ou que seu comportamento seja, de alguma forma, incorreto. Nesse caso, você pode ser mais enérgico e bloquear esse usuário. Normalmente, isso é feito bloqueando-se uma chave de API ou um intervalo de endereços IP.
- **Criar aplicativos que degradem normalmente.** A carga em um aplicativo pode exceder a capacidade de uma ou mais partes, causando disponibilidade reduzida e conexões com falha. Dimensionamento pode atenuar esse problema, mas ele pode atingir um limite imposto por outros fatores, como disponibilidade de recursos ou custo. Quando um aplicativo atinge o limite de um recurso, ele deve tomar uma ação apropriada para minimizar o impacto para o usuário. Por exemplo, em um sistema de comércio eletrônico, se o subsistema de processamento de pedidos estiver sobrecarregado ou falhar, ele pode ser desabilitado temporariamente, permitindo que outras funcionalidades, como procurar o catálogo de produtos. Pode ser apropriado adiar solicitações a um subsistema com falha &mdash; por exemplo, permitindo que os clientes enviem pedidos, mas salvando-os para processamento posterior, quando o subsistema de pedidos estiver disponível novamente.
- **Tratar eventos rápidos de intermitência normalmente.** A maioria dos aplicativos precisa lidar com cargas de trabalho que variam ao longo do tempo. Dimensionamento automático pode ajudar a lidar com a carga, mas pode levar algum tempo para instâncias adicionais ficarem online e lidar com solicitações. Para evitar picos de atividade sobrecarreguem o aplicativo, o design para enfileirar solicitações para os serviços que usa e degradar normalmente quando as filas estiverem próximos da capacidade. Verifique se há desempenho e capacidade suficientes disponíveis sob condições sem intermitência para esvaziar as filas e tratar de solicitações pendentes. Para saber mais, confira [Padrão de nivelamento de carga baseado em fila](../patterns/queue-based-load-leveling.md).
- **Compor ou executar failback para vários componentes.** Crie aplicativos para usar múltiplas instâncias sem afetar a operação e as conexões existentes, sempre que possível. Para maximizar a disponibilidade, use várias instâncias e distribuir solicitações entre elas e detectar e evitar o envio de solicitações para instâncias com falha.
- **Executar failback para um fluxo de trabalho ou um serviço diferente.** Por exemplo, se a gravação no banco de dados SQL falhar, temporariamente armazene dados no armazenamento de BLOBs ou Cache Redis. Forneça uma forma para repetir as gravações no Banco de Dados SQL quando o serviço ficar disponível. Em alguns casos, uma operação com falha pode ter uma ação alternativa que permite que o aplicativo continue a funcionar, mesmo quando um componente ou serviço falha. Se possível, detectar falhas e redirecionar as solicitações para outros serviços, enquanto o serviço primário estiver offline.
- **Use o nivelamento de carga para suavizar picos no tráfego.** Aplicativos podem enfrentar picos repentinos no tráfego e sobrecarregar o serviços de back-end. Se um serviço de back-end não pode responder a solicitações rápido o suficiente, as solicitações pendentes podem se acumular ou o serviço pode restringir o aplicativo. Para evitar isso, você pode usar uma fila como buffer. Quando há um novo item de trabalho, em vez de chamar o serviço de back-end imediatamente, o aplicativo enfileira um item de trabalho para ser executado de forma assíncrona. A fila atua como buffer e diminui os picos na carga. Para obter mais informações, consulte [padrão de nivelamento de carga baseado em fila](../patterns/queue-based-load-leveling.md).

## <a name="manage-your-data"></a>Gerenciar seus dados

Como gerenciar seus dados é reproduzido diretamente para a disponibilidade do seu aplicativo. As tarefas nesta seção podem ajudá-lo a criar um plano de gerenciamento para ajudar a garantir a disponibilidade.

- **Replicar os dados e entender os métodos de replicação para armazenamentos de dados do seu aplicativo.** A replicação de dados é uma estratégia geral para manipular falhas não transitórias em um armazenamento de dados. Considere os caminhos de leitura e gravação. Dependendo da tecnologia de armazenamento, você pode ter várias réplicas graváveis, ou você pode ter uma única réplica gravável e várias réplicas de somente leitura. Para maximizar a disponibilidade, as réplicas podem ser colocadas em várias regiões. No entanto, essa abordagem aumenta a latência na replicação de dados. Normalmente, a replicação entre regiões é feita de forma assíncrona, o que implica um modelo de consistência eventual e a possível perda de dados, se uma réplica falhar.  

  Você pode usar [Azure Site Recovery](/azure/site-recovery/azure-to-azure-quickstart/) para replicar máquinas virtuais do Azure de uma região para outra. O Site Recovery replica os dados continuamente para a região de destino. Quando ocorrer uma interrupção no seu site primário, você realiza o failover para um local secundário.

- **Assegure que nenhuma conta de usuário individual tenha acesso aos dados de backup e de produção.** Os backups de dados são comprometidos se uma única conta de usuário tem permissão para gravar tanto para origens de gravação quanto de backup. Um usuário mal-intencionado pode excluir propositadamente todos os seus dados e um usuário normal pode excluí-los acidentalmente. Projete seu aplicativo para limitar as permissões de cada conta de usuário. Somente conceder acesso de gravação a usuários que precisam dele e conceder acesso a produção ou backup, mas não ambos.
- **Documente e teste o processo de failover e failback de repositório de dados.** Se um repositório de dados falhe de modo catastrófico, um operador humano siga um conjunto de instruções documentadas para fazer failover para um novo repositório de dados. Se as etapas documentadas tiverem erros, um operador não será possível com êxito, segui-las e fazer failover do recurso. Teste regularmente as etapas de instrução para verificar se um operador que segue a documentação com êxito pode fazer failover e failback.
- **Fazer backup dos dados e validar os backups de dados.** Executar regularmente um script para validar a integridade dos dados, esquema e consultas para garantir que os dados de backup são o esperado. Registre em log e relate as inconsistências de modo que o serviço de backup possa ser reparado.
- **Use backup periódico e restauração point-in-time.** Regularmente e automaticamente fazer backup de dados que não são preservados em outro lugar. Verifique se que você pode restaurar de modo confiável os dados e o próprio aplicativo se ocorrer falha. Certifique-se de que os backups de atender ao RPO. Replicação de dados não é um recurso de backup porque o erro humano ou operações maliciosas podem corromper dados em todas as réplicas. O processo de backup deve ser seguro, para proteger os dados em trânsito e em armazenamento. Bancos de dados geralmente podem ser recuperados para um ponto anterior no tempo usando os logs de transação. Para obter mais informações, consulte [recuperação de dados corrompidos ou exclusão acidental](../resiliency/recovery-data-corruption.md).
- **Considere o uso de uma conta de armazenamento com redundância geográfica.** Dados armazenados em uma Conta de Armazenamento do Azure são sempre replicados localmente. No entanto, há várias estratégias de replicação para escolher quando uma conta de armazenamento é provisionada. Para proteger os dados do aplicativo no caso raro quando uma região inteira fica indisponível, marque [armazenamento com redundância geográfica do Azure acesso de leitura (RA-GRS)](/azure/storage/storage-redundancy/#read-access-geo-redundant-storage).  

    > [!NOTE]
    > Para VMs, não dependa da replicação de RA-GRS para restaurar os discos de VM (arquivos VHD). Em vez disso, use o [Backup do Azure](/azure/backup).

- **Considere a implantação de dados de referência para várias regiões.** Os dados de referência são somente leitura e compatíveis com a funcionalidade do aplicativo. Ele normalmente não muda com frequência. Embora a restauração do backup é uma maneira de lidar com interrupções de serviço em toda a região, o RTO é relativamente longo. Quando você implanta o aplicativo em uma região secundária, algumas estratégias podem melhorar o RTO para dados de referência.

    Porque as alterações de dados de referência com pouca frequência, você pode melhorar o RTO mantendo uma cópia permanente na região secundária. Isso elimina o tempo necessário para restaurar backups após um desastre. Para atender aos requisitos de recuperação de desastre em várias regiões, você deve implantar o aplicativo e os dados de referência juntos em várias regiões.

- **Use a simultaneidade otimista e consistência eventual.** As transações que bloqueiam o acesso aos recursos por meio de bloqueio (*simultaneidade pessimista*) pode causar baixo desempenho e reduzir a disponibilidade. Esses problemas podem se tornar especialmente críticos em sistemas distribuídos. Em muitos casos, o design cuidadoso e técnicas, como particionamento, podem minimizar a possibilidade de ocorrência de atualizações conflitantes. Se os dados são replicados ou ler de um repositório atualizado separadamente, os dados só serão eventualmente consistentes. Mas as vantagens normalmente superam o impacto na disponibilidade do uso de transações para garantir consistência imediata.
- **Use a replicação geográfica ativa para banco de dados SQL para replicar as alterações para um banco de dados secundário.** A replicação geográfica ativa para banco de dados SQL replica automaticamente alterações de banco de dados para bancos de dados secundários na mesma região ou uma região diferente. Para obter mais informações, consulte [criando e usando a replicação geográfica ativa](/azure/sql-database/sql-database-active-geo-replication).

  Como alternativa, você pode adotar uma abordagem mais manual usando o **cópia de banco de dados** comando para criar uma cópia de backup do banco de dados com consistência transacional. Você também pode usar o serviço de importação/exportação do Banco de Dados SQL do Azure, que oferece suporte à exportação de bancos de dados para arquivos BACPAC (arquivos compactados contendo o esquema de banco de dados e dados associados) que são armazenados no armazenamento de Blobs do Azure. O armazenamento do Azure cria duas réplicas do arquivo de backup na mesma região. No entanto, a frequência do processo de backup determina o RPO, que é a quantidade de dados que você pode perder em cenários de desastre. Por exemplo, se você fazer backup de dados a cada hora e um desastre ocorre dois minutos antes do backup, você perderá 58 minutos de dados. Além disso, para se proteger de uma interrupção do serviço de toda a região, você deve copiar os arquivos BACPAC para uma região alternativa. Para obter mais informações, consulte [visão geral da continuidade dos negócios com o banco de dados do Azure SQL](/azure/sql-database/sql-database-business-continuity).

- **Use backups geográficos do SQL Data Warehouse.** Para o SQL Data Warehouse, use [backups geográficos](/azure/sql-data-warehouse/backup-and-restore) para restaurar uma região emparelhada para recuperação de desastre. Esses backups são realizados a cada 24 horas e podem ser restaurados em 20 minutos na região emparelhada. Esse recurso está ativado por padrão para todas as instâncias do SQL Data Warehouse. Para obter mais informações sobre como restaurar seu data warehouse, consulte [restaurar a partir de uma região geográfica do Azure usando o PowerShell.](/azure/sql-data-warehouse/sql-data-warehouse-restore)

- **Replique discos de VMs usando o Azure Site Recovery.** Quando você replicar VMs do Azure usando [recuperação de Site](/azure/site-recovery/), todos os discos VM são replicados continuamente para a região de destino assincronamente. Os pontos de replicação são criados a cada poucos minutos. Isso lhe dá um RPO na ordem de minutos.
- **Fazer backup do SQL Server em execução em VMs ou configure uma sessão de envio de logs.** Para o SQL Server em execução em VMs, há duas opções: backups tradicionais e envio de logs. Backups tradicionais permitem que você restaurar para um ponto específico no tempo, mas o processo de recuperação é lento. Restauração de backups tradicionais exige que você comece com um backup completo inicial e, em seguida, aplique quaisquer backups feitos depois que. A segunda opção é configurar uma sessão de envio de logs para atrasar a restauração de backups de log (por exemplo, por duas horas). Isso fornece uma janela para recuperação de erros feitos no primário.
- **Use uma ferramenta de terceiros ou de processo personalizado para o backup do armazenamento do Azure.** Armazenamento do Azure, você pode desenvolver um processo de backup personalizado ou usar uma ferramenta de backup de terceiros. A maioria dos designs de aplicativo tem complexidades adicionais, no qual armazenamento recursos referenciam uns aos outros. Por exemplo, considere um banco de dados SQL com uma coluna que se vincula a um blob no armazenamento do Azure. Se os backups não acontecerem simultaneamente, o banco de dados poderá ter um ponteiro voltado a um blob do qual não foi feito backup antes da falha. O plano de recuperação de desastre ou aplicativo deve implementar processos para tratar dessa inconsistência após uma recuperação.
- **Use os recursos de instantâneo ou replicação nativa para outras plataformas de dados hospedadas em máquinas virtuais.** Outras plataformas de dados, como Elasticsearch ou MongoDB, têm seus próprios recursos e considerações ao criar um backup integrado e o processo de restauração. Para essas plataformas de dados, a recomendação geral é usar os recursos de instantâneo ou de qualquer replicação baseada em integração nativa ou disponível. Se esses recursos não existem ou não são adequados, considere o uso de instantâneos de disco ou Backup do Azure para criar uma cópia de point-in-time de dados do aplicativo. Em todos os casos, é importante determinar como realizar backups consistentes, especialmente quando os dados de aplicativo se estende por vários sistemas de arquivos ou várias unidades são combinadas em um único sistema de arquivos.
- **Entenda os métodos de replicação para as fontes de dados do aplicativo.** Os dados do aplicativo serão armazenados em diferentes fontes de dados e serão variaram com requisitos de disponibilidade. Avaliar os métodos de replicação para cada tipo de armazenamento de dados no Azure, incluindo [redundância do armazenamento do Azure](/azure/storage/storage-redundancy/) e [banco de dados SQL a replicação geográfica ativa](/azure/sql-database/sql-database-geo-replication-overview/) para garantir que seu aplicativo dados requisitos forem atendidos. Se você replicar VMs do Azure usando [recuperação de Site](/azure/site-recovery/), todos os discos VM são replicados continuamente para a região de destino assincronamente. Os pontos de replicação são criados a cada poucos minutos.
- **Estabeleça estratégias de dados para recuperação de desastres.** Tratamento adequado dos dados é um aspecto desafiador de qualquer plano de recuperação de desastres. Durante o processo de recuperação, a restauração de dados geralmente leva mais tempo. Opções diferentes para reduzir a funcionalidade resultam em desafios difíceis para recuperação de dados e consistência.

## <a name="next-steps"></a>Próximos passos

> [!div class="nextstepaction"]
> [Testar a resiliência e disponibilidade](./testing.md)
