---
title: Diretrizes gerais de repetição
description: Orientações sobre repetição no tratamento de falhas transitórias.
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 9562e3447b2219fe2f3df96cfca24b845efa39b0
ms.sourcegitcommit: c53adf50d3a787956fc4ebc951b163a10eeb5d20
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/23/2017
---
# <a name="transient-fault-handling"></a>Tratamento de falhas transitórias

[!INCLUDE [header](../_includes/header.md)]

Todos os aplicativos que se comunicam com serviços e recursos remotos são suscetíveis a falhas transitórias. Especificamente, esse é o caso de aplicativos que são executados na nuvem, onde a natureza do ambiente e da conectividade pela Internet significam que esses tipos de falha provavelmente podem ser encontrados com mais frequência. As falhas transitórias incluem a perda momentânea da conectividade de rede com componentes e serviços, a indisponibilidade temporária de um serviço ou tempos limite que surgem quando um serviço está ocupado. Essas falhas geralmente são autocorretivas e, se a ação for repetida após um tempo razoável, é provável que seja bem-sucedida.

Este documento aborda as diretrizes gerais para lidar com falhas transitórias. Para obter informações sobre como lidar com falhas transitórias ao usar os serviços do Microsoft Azure, consulte [Diretrizes para repetição específica de serviços do Azure](./retry-service-specific.md).

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>Por que ocorrem falhas transitórias na nuvem?
As falhas transitórias podem ocorrer em qualquer ambiente, em qualquer plataforma ou sistema operacional e em qualquer tipo de aplicativo. Em soluções que são executadas na infraestrutura local, o desempenho e a disponibilidade do aplicativo e seus componentes geralmente são mantidos por meio de redundância de hardware muitas vezes subutilizada e cara, e os componentes e recursos são localizados próximos um do outro. Embora isso torne uma falha menos provável, isso ainda pode resultar em falhas transitórias e, até mesmo, em uma interrupção por meio de eventos inesperados, como problemas externos de rede e fonte de energia, ou outros cenários de desastre.

A hospedagem da nuvem, incluindo sistemas de nuvem privada, pode oferecer uma disponibilidade geral mais alta usando recursos compartilhados, redundância, failover automático e alocação dinâmica de recursos em um grande número de nós de computação primários. No entanto, a natureza desses ambientes pode significar que falhas transitórias têm mais probabilidade de ocorrer. Há vários motivos para isso:

* Muitos recursos em um ambiente de nuvem são compartilhados e o acesso a eles está sujeito à limitação para proteger o recurso. Alguns serviços recusarão conexões quando a carga subir para um nível específico, ou uma taxa de transferência máxima for atingida, para permitir o processamento de solicitações existentes e manter o desempenho do serviço para todos os usuários. A limitação ajuda a manter a qualidade do serviço para vizinhos e outros locatários que estão usando o recurso compartilhado.
* Os ambientes de nuvem são criados usando grandes números de unidades de hardware primárias. Eles proporcionam desempenho distribuindo dinamicamente a carga por várias unidades de computação e componentes de infraestrutura, bem como oferecem confiabilidade reciclando ou substituindo automaticamente as unidades com falha. Essa natureza dinâmica significa que falhas transitórias e de conexão temporária podem ocorrer ocasionalmente.
* Muitas vezes, há mais componentes de hardware, incluindo estrutura de rede, como roteadores e balanceadores de carga, entre o aplicativo e os recursos e serviços que ele usa. Essa infraestrutura adicional pode, ocasionalmente, introduzir latência de conexão adicional e falhas de conexão transitórias.
* As condições de rede entre o cliente e o servidor podem ser variáveis, especialmente quando a comunicação atravessa a Internet. Mesmo em pontos locais, as cargas de tráfego muito pesadas podem atrasar a comunicação e causar falhas de conexão intermitentes.

## <a name="challenges"></a>Desafios
As falhas transitórias podem ter um enorme impacto na disponibilidade percebida de um aplicativo, mesmo que ele tenha sido integralmente testado sob todas as circunstâncias previsíveis. Para garantir que aplicativos hospedados na nuvem operem de forma confiável, eles devem ser capazes de responder aos seguintes desafios:

* O aplicativo deve ser capaz de detectar falhas quando elas ocorrerem e determinar se essas falhas têm probabilidade de serem transitórias, de duração mais longa ou falhas de terminal. Diferentes recursos têm mais probabilidade de retornar respostas diferentes quando uma falha ocorre, e essas respostas também podem variar de acordo com o contexto da operação; por exemplo, a resposta de um erro ao ler no armazenamento pode ser diferente da resposta de um erro ao gravar no armazenamento. Muitos recursos e serviços têm contratos de falha transitória bem documentados. No entanto, quando essas informações não estão disponíveis, pode ser difícil descobrir a natureza da falha e se há probabilidade de que ela seja transitória.
* O aplicativo deve poder repetir a operação se determinar que a falha pode ser transitória e acompanhar o número de vezes que a operação foi repetida.
* O aplicativo deve usar uma estratégia apropriada para as repetições. Essa estratégia especifica o número de vezes que ele deve tentar novamente, o intervalo entre cada tentativa e as ações a serem executadas após cada tentativa que falhar. O número apropriado de tentativas e o intervalo entre cada uma delas costumam ser difíceis de determinar e variam de acordo com o tipo de recurso, bem como das condições operacionais do recurso e do próprio aplicativo.

## <a name="general-guidelines"></a>Diretrizes gerais
As diretrizes a seguir ajudarão você a projetar um mecanismo adequado para tratamento de falha transitória de seus aplicativos:

* **Determine se há um mecanismo interno de repetição:**
  * Muitos serviços fornecem uma biblioteca de cliente ou um SDK que contém um mecanismo de tratamento para falha transitória. A política de repetição usada por ele geralmente é personalizado para a natureza e os requisitos do serviço de destino. Como alternativa, as interfaces REST para serviços podem retornar informações que são úteis para determinar se uma repetição é apropriada e quanto tempo esperar antes da próxima tentativa de repetição.
  * Use o mecanismo interno de repetição onde houver um disponível, a menos que haja requisitos específicos e bem entendidos que significam que um comportamento de repetição diferente é mais adequado.
* **Determine se a operação é adequada para repetição**:
  * Você deve repetir a operação apenas onde as falhas forem transitórias (geralmente indicadas pela natureza do erro) e se houver, pelo menos, alguma probabilidade de que a operação seja bem-sucedida na nova tentativa. Não faz sentido repetir operações que indicam uma operação inválida, como atualização de um banco de dados para um item que não existe, ou solicitações para um serviço ou recurso que sofreu um erro fatal.
  * Em geral, você deve implementar novas tentativas apenas onde o impacto total disso puder ser determinado, e as condições forem bem entendidas e puderem ser validadas. Caso contrário, deixe que o código de chamada implemente as novas tentativas. Lembre-se de que os erros retornados de recursos e serviços fora do seu controle podem evoluir ao longo do tempo, e talvez seja necessário rever sua lógica de detecção de falhas transitórias.
  * Ao criar serviços ou componentes, considere a implementação de mensagens e códigos de erro que ajudarão os clientes a determinar se devem repetir as operações com falha. Em particular, indique se o cliente deve repetir a operação (talvez retornando um valor **isTransient** ) e sugira um intervalo adequado antes da próxima tentativa de repetição. Se você criar um serviço Web, considere retornar erros personalizados definidos em seus contratos de serviço. Mesmo que os clientes genéricos não possam lê-los, eles serão úteis na criação de clientes personalizados.
* **Determine uma contagem de repetições e intervalo apropriados:**
  * É fundamental otimizar a contagem de repetições e o intervalo para o tipo de caso de uso. Se você não repetir um número de vezes suficiente, o aplicativo não poderá concluir a operação e, provavelmente, apresentar uma falha. Se você repetir muitas vezes, ou com um intervalo muito curto entre as tentativas, há grandes chances de que o aplicativo retenha recursos como threads, conexões e memória por longos períodos, o que afetará negativamente a integridade do aplicativo.
  * Os valores apropriados para o intervalo de tempo e o número de tentativas de repetição dependem do tipo de operação que está sendo tentada. Por exemplo, se a operação fizer parte de uma interação do usuário, o intervalo deverá ser curto e apenas algumas tentativas deverão ser feitas a fim de evitar que os usuários tenham que esperar por uma resposta (o que retém conexões abertas e pode reduzir a disponibilidade para outros usuários). Se a operação fizer parte de um fluxo de trabalho de execução longa ou crítico, onde cancelar e reiniciar o processo seja caro ou demorado, é apropriado aguardar mais tempo entre as tentativas e repetir mais vezes.
  * Determinar os intervalos apropriados entre repetições é a parte mais difícil na criação de uma estratégia bem-sucedida. As estratégias comuns usam os seguintes tipos de intervalo de repetição:
    * **Retirada exponencial**. O aplicativo aguarda pouco tempo antes da primeira repetição e depois os tempos aumentam exponencialmente entre as repetições subsequentes. Por exemplo, ele pode repetir a operação depois de 3 segundos, 12 segundos, 30 segundos e assim por diante.
    * **Intervalos incrementais**. O aplicativo aguarda pouco tempo antes da primeira repetição e depois os tempos aumentam de modo incremental entre as repetições subsequentes. Por exemplo, ele pode repetir a operação depois de 3 segundos, 7 segundos, 13 segundos e assim por diante.
    * **Intervalos regulares**. O aplicativo aguarda o mesmo período entre cada tentativa. Por exemplo, ele pode repetir a operação a cada 3 segundos.
    * **Repetição imediata**. Às vezes, uma falha transitória é extremamente curta, talvez devido a um evento, como uma colisão de pacote de rede ou um pico em um componente de hardware. Neste caso, repetir a operação imediatamente é apropriado, pois ela poderá ser bem-sucedida se a falha for removida no tempo que leva para o aplicativo montar e enviar a próxima solicitação. No entanto, nunca deverá haver mais de uma tentativa de repetição imediata, e você deverá tentar estratégias alternativas, como retirada exponencial ou ações de fallback, caso a repetição imediata falhe.
    * **Aleatoriedade**. Qualquer uma das estratégias de repetição listadas acima pode incluir uma aleatoriedade para impedir que várias instâncias do cliente enviem tentativas de repetição subsequentes ao mesmo tempo. Por exemplo, uma instância pode repetir a operação após 3 segundos, 11 segundos, 28 segundos e assim por diante, enquanto outra instância pode repetir a operação após 4 segundos, 12 segundos, 26 segundos e assim por diante. A aleatoriedade é uma técnica útil que pode ser combinada com outras estratégias.  
  * Como regra geral, use uma estratégia de retirada exponencial para operações em segundo plano, bem como estratégias de repetição de intervalo regular ou imediato para operações interativas. Em ambos os casos, você deve escolher o intervalo e a contagem de repetições para que a latência máxima de todas as tentativas de repetição esteja dentro do requisito obrigatório de latência de ponta a ponta.
  * Leve em consideração a combinação de todos os fatores que contribuem para o tempo limite geral máximo de uma operação repetida. Esses fatores incluem o tempo necessário para que uma conexão com falha gere uma resposta (normalmente definido por um valor de tempo limite do cliente), bem como o intervalo entre tentativas de repetição e o número máximo de repetições. O total de todos esses tempos pode resultar em um número de vezes de operação bem alto, especialmente ao usar uma estratégia de intervalo exponencial onde o intervalo entre repetições aumenta rapidamente após cada falha. Se um processo deve atender a um SLA (contrato de nível de serviço) específico, o tempo de operação geral, incluindo todos os tempos limite e intervalos, deverá estar dentro do que foi definido no SLA
  * Estratégias de repetição superagressivas, que têm intervalos muito curtos ou muitas repetições, podem ter um efeito negativo no recurso ou serviço de destino. Isso pode impedir que o recurso ou serviço se recupere de seu estado sobrecarregado, e ele continuará bloqueando ou recusando solicitações. Isso resulta em um círculo vicioso onde cada vez mais solicitações são enviadas para o recurso ou serviço e, consequentemente, sua capacidade de recuperação é ainda mais reduzida.
  * Leve em conta o tempo limite das operações ao escolher os intervalos de repetição para evitar iniciar uma tentativa subsequente imediatamente (por exemplo, se o período de tempo limite for semelhante ao intervalo de repetição). Além disso, considere se você precisa manter o período possível total (o tempo limite mais os intervalos de repetição) abaixo de um tempo total específico. As operações com tempos limite extraordinariamente curtos ou muito longos podem influenciar o tempo de espera e quantas vezes repetir a operação.
  * Use o tipo da exceção e quaisquer dados que ele contenha, ou os códigos e mensagens de erro retornados do serviço, para otimizar o intervalo e o número de repetições. Por exemplo, alguns códigos de erro ou exceções (como o código HTTP 503 Serviço Indisponível com um cabeçalho Repetir Após na resposta) podem indicar quanto tempo o erro pode durar ou que o serviço falhou e não responderá a nenhuma tentativa subsequente.
* **Evite antipadrões**:
  * Na grande maioria dos casos, você deve evitar implementações que incluam camadas duplicadas de código de repetição. Evite designs que incluam mecanismos de repetição em cascata ou que implementam a repetição em cada fase de uma operação que envolva uma hierarquia de solicitações, a menos que tenha requisitos específicos que a exijam. Nessas circunstâncias excepcionais, use políticas que evitem números de repetições e períodos de intervalo excessivos, e assegure-se de entender as consequências. Por exemplo, se um componente fizer uma solicitação para outro, que então acessa o serviço de destino, e você implementar a repetição com uma contagem de três em ambas as chamadas, no total, haverá nove tentativas de repetição no serviço. Muitos serviços e recursos implementam um mecanismo interno de repetição e você deve investigar como pode desabilitá-lo ou modificá-lo, caso precise implementar repetições em um nível mais alto.
  * Nunca implemente um mecanismo de repetição infinita. Isso provavelmente impedirá o recurso ou serviço de se recuperar de situações de sobrecarga e fará com que conexões recusadas e a limitação continuem por um período ainda mais longo. Use um número finito ou repetições, ou implemente um padrão como [Disjuntor](http://msdn.microsoft.com/library/dn589784.aspx) para permitir que o serviço se recupere.
  * Nunca execute uma repetição imediata mais de uma vez.
  * Evite usar um intervalo de repetição regular, especialmente quando você tem um grande número de tentativas de repetição, ao acessar serviços e recursos no Azure. A abordagem ideal nesse cenário é uma estratégia de retirada exponencial com um recurso de interrupção do circuito.
  * Impeça que várias instâncias do mesmo cliente, ou várias instâncias de diferentes clientes, enviem repetições ao mesmo tempo. Se houver probabilidade de isso acontecer, introduza uma aleatoriedade nos intervalos de repetição.
* **Teste sua estratégia de repetição e implementação:**
  * Assegure-se de testar completamente a implementação da estratégia de repetição sob o maior número de circunstâncias possível, especialmente quando o aplicativo e os recursos ou serviços de destino que ele usa estiverem sob carga extrema. Para verificar o comportamento durante o teste, você pode:
    * Injetar falhas transitórias e não transitórias no serviço. Por exemplo, envie solicitações inválidas ou adicione código que detecte solicitações de teste e responda com diferentes tipos de erro. Para obter um exemplo usando o TestApi, consulte [Teste de injeção de falha com o TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) e [Introdução ao TestApi – parte 5: APIs de injeção de falhas por código gerenciado](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).
    * Criar uma simulação do recurso ou serviço que retorne uma gama de erros que o serviço real pode retornar. Certifique-se de incluir todos os tipos de erro que sua estratégia de repetição foi projetada para detectar.
    * Forçar a ocorrência de erros transitórios desabilitando ou sobrecarregando temporariamente o serviço se for um serviço personalizado que você criou e implantou (você não deve, é claro, tentar sobrecarregar nenhum recurso ou serviço compartilhado no Azure).
    * Para APIs baseadas em HTTP, pensar em usar a biblioteca FiddlerCore em seus testes automatizados para alterar a saída das solicitações HTTP, seja adicionando tempos extras de viagem de ida e volta, seja alterando a resposta (como código de status HTTP, cabeçalhos, corpo ou outros fatores). Isso permite o teste determinista de um subconjunto das condições de falha, sejam falhas transitórias ou outros tipos de falha. Para saber mais, consulte [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore). Para obter exemplos de como usar a biblioteca, especificamente a classe **HttpMangler** , examine o [código-fonte do SDK do Armazenamento do Azure](https://github.com/Azure/azure-storage-net/tree/master/Test).
    * Execute o fator de carga alta e testes simultâneos para garantir que o mecanismo e a estratégia de repetição funcionem corretamente sob essas condições, e não tenham um efeito negativo na operação do cliente nem causem contaminação cruzada entre solicitações.
* **Gerencie as configurações de política de repetição:**
  * Uma *política de repetição* é uma combinação de todos os elementos de sua estratégia de repetição. Ela define o mecanismo de detecção que determina se uma falha tem probabilidade de ser transitória, o tipo de intervalo a ser usado (como regular, retirada exponencial e aleatoriedade), os valores reais de intervalo e o número de vezes da repetição.
  * As repetições devem ser implementadas em muitos locais até mesmo no aplicativo mais simples e em cada camada dos aplicativos mais complexos. Em vez de embutir os elementos em código de cada política em vários locais, pense em usar um ponto central para armazenar todas as políticas. Por exemplo, armazene os valores como o intervalo e a contagem de repetições em arquivos de configuração de aplicativo, leia-os no tempo de execução e crie as políticas de repetição de modo programático. Isso facilita o gerenciamento das configurações, bem como modificar e ajustar os valores para que respondam aos requisitos e cenários em constante mudança. No entanto, projete o sistema para armazenar os valores em vez de reler um arquivo de configuração toda vez e garanta que padrões adequados sejam usados se os valores não puderem ser obtidos da configuração.
  * Em um aplicativo de Serviços de Nuvem do Azure, pense em armazenar os valores que são usados para criar as políticas de repetição no tempo de execução no arquivo de configuração de serviço, de modo que elas possam ser alteradas sem a necessidade de reiniciar o aplicativo.
  * Aproveite as estratégias de repetição padrão ou internas disponíveis nas APIs do cliente que você usa, mas somente onde elas forem apropriadas para seu cenário. Essas estratégias geralmente são para fins gerais. Em alguns cenários, elas podem ser tudo o que é necessário, mas em outros, elas podem não oferecer a gama total de opções adequadas aos seus requisitos específicos. Você deve entender como as configurações afetarão o aplicativo por meio de testes que determinam a maioria dos valores apropriados.
* **Registre em log e rastreie falhas transitórias e não transitórias:**
  * Como parte de sua estratégia de repetição, inclua o tratamento de exceções e outra instrumentação que é registrada em log quando são feitas tentativas de repetição. Embora uma falha transitória ocasional e a repetição sejam esperadas, e não indiquem um problema, números regulares e crescentes de repetições, muitas vezes, são um indicador de um problema que pode causar uma falha ou que pode estar afetando, no momento, o desempenho e a disponibilidade do aplicativo.
  * Registre falhas transitórias em log como entradas de Aviso em vez de entradas de Erro, de modo que a monitoração dos sistemas não as detecte como erros de aplicativo que podem disparar alertas falsos.
  * Considere armazenar um valor em suas entradas de log que indique se as repetições foram causadas por limitação no serviço ou por outros tipos de falha, como falhas de conexão, para que você possa diferenciá-las durante a análise dos dados. Um aumento no número de erros de limitação geralmente é um indicador de uma falha de design no aplicativo ou a necessidade de alternar para um serviço premium que ofereça hardware dedicado.  
  * Considere a possibilidade de medir e registrar em log o tempo geral necessário para operações que incluem um mecanismo de repetição. Esse é um bom indicador do efeito geral das falhas transitórias nos tempos de resposta do usuário, na latência de processo e na eficiência dos casos de uso do aplicativo. Registre também o número de repetições ocorridas para entender os fatores que contribuíram para o tempo de resposta.
  * Considere implementar um sistema de telemetria e monitoramento que possa gerar alertas quando o número e a taxa de falhas, o número médio de repetições ou os tempos gerais necessários para que as operações sejam bem-sucedidas, estiverem aumentando.
* **Gerencie operações que falham continuamente:**
  
  * Haverá circunstâncias em que a operação continuará falhando a cada tentativa, e é essencial considerar como você tratará essa situação:
    * Embora uma estratégia de repetição defina o número máximo de vezes que uma operação deve ser repetida, ela não impede que o aplicativo repita a operação novamente, com o mesmo número de repetições. Por exemplo, se um serviço de processamento de pedido falhar com um erro fatal que o faça parar de funcionar permanentemente, a estratégia de repetição poderá detectar um tempo limite de conexão e considerá-la uma falha transitória. O código repetirá a operação um número especificado de vezes e só então desistirá. No entanto, quando outro cliente fizer um pedido, a operação será tentada novamente, mesmo com a certeza de que falhará todas as vezes.
    * Para impedir as repetições constantes de operações que falham continuamente, pense na implementação do padrão de [Disjuntor](http://msdn.microsoft.com/library/dn589784.aspx). Nesse padrão, se o número de falhas em uma janela de tempo especificada exceder o limite, as solicitações serão retornadas ao originador imediatamente como erros, sem tentar acessar o recurso ou serviço com falha.
    * O aplicativo pode testar o serviço periodicamente, de forma intermitente e com intervalos bastante longos entre as solicitações a fim de detectar quando ele se torna disponível. Um intervalo apropriado dependerá do cenário, como a importância da operação e a natureza do serviço, e pode ser entre alguns minutos e várias horas. No ponto em que o teste for bem-sucedido, o aplicativo pode retomar as operações normais e passar solicitações ao serviço recém-recuperado.
    * Enquanto isso, é possível fazer fallback para outra instância do serviço (talvez em outro datacenter ou aplicativo), usar um serviço semelhante que ofereça funcionalidade compatível (talvez mais simples) ou executar algumas operações alternativas na esperança de que o serviço logo estará disponível. Por exemplo, talvez seja apropriado armazenar solicitações para o serviço em uma fila ou um repositório de dados e repeti-las mais tarde. Caso contrário, talvez você possa redirecionar o usuário para uma instância alternativa do aplicativo, reduzir o desempenho do aplicativo, mas ainda oferecer funcionalidade aceitável, ou apenas retornar uma mensagem ao usuário indicando que o aplicativo não está disponível no momento.
* **Outras considerações**
  
  * Ao decidir sobre os valores para o número de repetições e os intervalos de repetição para uma política, considere se a operação no serviço ou recurso faz parte de uma operação de execução longa ou de várias etapas. Pode ser difícil ou dispendioso compensar todas as outras etapas operacionais que já foram bem-sucedidas quando uma falha. Nesse caso, um intervalo muito longo e um grande número de repetições podem ser aceitáveis, desde que isso não bloqueie outras operações mantendo ou prendendo recursos escassos.
  * Considere se repetir a mesma operação pode causar inconsistências nos dados. Se algumas partes de um processo de várias etapas forem repetidas e as operações não forem idempotentes, isso poderá resultar em uma inconsistência. Por exemplo, uma operação que incrementa um valor, se repetida, produzirá um resultado inválido. Repetir uma operação que envia uma mensagem a uma fila poderá causar uma inconsistência no consumidor da mensagem se ele não puder detectar mensagens duplicadas. Para evitar isso, assegure-se de projetar cada etapa como uma operação idempotente. Para saber mais sobre idempotência, consulte [Padrões de idempotência][idempotency-patterns].
  * Considere o escopo das operações que serão repetidas. Por exemplo, pode ser mais fácil implementar o código de repetição em um nível que englobe várias operações e repetir todas elas se uma falhar. No entanto, fazer isso pode resultar em problemas de idempotência ou em operações de reversão desnecessárias.
  * Se você escolher um escopo de repetição que englobe várias operações, leve em conta a latência total de todos elas ao determinar os intervalos de repetição, ao monitorar o tempo gasto e antes de gerar alertas para falhas.
  * Considere como sua estratégia de repetição pode afetar vizinhos e outros locatários em um aplicativo compartilhado ou ao usar os serviços e recursos compartilhados. As políticas de repetição agressivas podem aumentar o número de falhas transitórias que ocorrem para esses outros usuários e para aplicativos que compartilham os recursos e serviços. Da mesma forma, seu aplicativo poderá ser afetado pelas políticas de repetição implementadas por outros usuários dos recursos e serviços. Para aplicativos de missão crítica, você pode decidir usar os serviços premium que não são compartilhados. Isso oferece muito mais controle sobre a carga e a limitação resultante desses recursos e serviços, o que pode ajudar a justificar o custo adicional.

## <a name="more-information"></a>Mais informações
* [Diretrizes para repetição específicas do serviço do Azure](./retry-service-specific.md)
* [Bloco de aplicativos de tratamento de falhas transitórias](http://msdn.microsoft.com/library/hh680934.aspx)
* [Padrão de Disjuntor](http://msdn.microsoft.com/library/dn589784.aspx)
* [Padrão de transação de compensação](http://msdn.microsoft.com/library/dn589804.aspx)
* [Padrões de idempotência][idempotency-patterns]

[idempotency-patterns]: http://blog.jonathanoliver.com/idempotency-patterns/

